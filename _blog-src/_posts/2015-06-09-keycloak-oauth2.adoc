---
layout: post
title:  "Keycloak and dagger: Securing your services with OAuth2"
date:   2015-06-09 13:25:28 +0100
author: marc_savy
categories: gateway security oauth2 keycloak authentication authorization
---

NOTE: A newer revision of this blogpost correct for http://fixme.local[apiman 1.2.x is available]. This version written for apiman 1.1.x, for which it remains valid.

One great advantage of API Management is centralising auth concerns, thereby avoiding burdensome reimplementation issues and streamlining your security processes. The good news is that you can easily configure apiman to handle many common auth use-cases, such as OAuth2 with our popular Keycloak OAuth2 policy which I'll outline in this blogpost.

////
Use this pattern to avoid asciidoctor rendering the HTML comment.
<!--more-->
////

== Preparation

For this example, let's assume we're using apiman's http://www.apiman.io/latest/download.html[quickstart] setup and have it running. I suggest using the _'Or simply try this...'_ box.

After you have your apiman quickstart running (replace *apiman-1.1.3.Final* in the path below with whatever version you downloaded), we can live deploy a handy *echo service* into our environment so we have something to test against:

```ShellSession
cd /tmp
git clone https://github.com/apiman/apiman-quickstarts.git
cd apiman-quickstarts/echo-service
git checkout 1.1.3.Final
mvn clean install
mvn wildfly:deploy
```

== Installing the Plugin

Those amongst you with some experience of apiman may have noticed that the OAuth2 policy doesn't appear in the standard list of policies in the manager UI; that's because the OAuth2 policy is an example of an *apiman plugin*, all of which are shipped separately from apiman, but are trivially easy to install. All you need to know is the GAV of the plugin, which in this case is:

[cols="2*", options="header"]
|===
|GAV
|Value

|Group
|io.apiman.plugins

|Artifact
|apiman-plugins-keycloak-oauth-policy

|Version
|1.1.3.Finalfootnote:[Use the version corresponding to your selected release of apiman]
|===

When logged into http://localhost:8080/apimanui/[the apiman manager UI] as an administrator (for the quickstart that's u:`admin`, p:`admin123!`), navigate to the *manage plugins* page:

image::/blog/images/2015-06-03/sysadmin-manage-plugins.png[alt="System Administration", link="http://www.apiman.io/latest/user-guide.html#_plugins"]

Select *add plugin*, fill in the details as above, and *add plugin*. That's it!

== Setting Up

There are two essential components to our system. First, is the http://keycloak.jboss.org[Keycloak server], an all-in-one https://en.wikipedia.org/wiki/Single_sign-on[SSO] and https://en.wikipedia.org/wiki/Identity_management[IdM]; we'll configure it to be our identity source and handle the issuance of OAuth2 bearer tokens. Second, is the apiman OAuth2 policy; we'll set it up to validate the tokens precisely to our requirements.

Let's assume we're going to protect a very simple *echo service*, which echoes back to the requestor the details of any request made to it. It is located at `http://localhost:8080/apiman-echo`.

=== Keycloak Server

IMPORTANT: There are a huge number of configuration permutations with Keycloak, and the most suitable approach will vary according to your requirements. It is highly recommended to consult the http://keycloak.jboss.org/docs.html[Keycloak guides] to determine your optimal setup, as for the sake of brevity we're only going to cover a couple of trivial preconfigured scenarios.

First, log into the http://localhost:8080/auth/admin[Keycloak server]. If you're following our walkthrough, the log-in details are identical to those mentioned earlier (`admin`, `admin123!`). You can see that there is already an *apiman* realm defined, but we're going to create a new one, so navigate to *Add Realm* (top right), and import and upload link:/blog/resources/2015-06-04/stottie.json[this demonstration realm definition]; it provides an extremely simple setup where we have:

- A realm: `stottie`
- A single user: `rincewind`, with password: `apiman` and a realm role: `echomeister`
- And, a client: `apiman`, which is allowed direct grants via Keycloak's https://keycloak.github.io/docs/userguide/keycloak-server/html/direct-access-grants.html[RESTful Direct Access Grants API].

Let's quickly test requesting ourselves an OpenID Connect OAuth2 token:

```ShellSession
curl -X POST http://127.0.0.1:8080/auth/realms/stottie/protocol/openid-connect/token  -H "Content-Type: application/x-www-form-urlencoded" -d "username=rincewind" -d 'password=apiman' -d 'grant_type=password' -d 'client_id=apiman'
```

This should return some JSON similar to the following:

```json
{
    "access_token": "eyJhbGciOiJSUzI1NiJ9...<SNIP>",
    "expires_in": 300,
    "refresh_expires_in": 1800,
    "refresh_token": "eyJhbGcg...<SNIP>",
    "not-before-policy": 0,
    "session-state": "69974623-be8b-49d7-840a-0330c6bdde21"
}
```

Notice that the OAuth2 token we're interested in is contained within the `access_token` field, with useful ancillary information about token validity and refreshing. If we base64 decode the token, we can see a lot interesting information, including the `echomiester` realm role defined on `rincewind`:

```json
{
    "jti": "c89b8cf7-84ef-4f02-9954-f8d3d4321473",
    "exp": 1433414538,
    "nbf": 0,
    "iat": 1433414238,
    "iss": "http://127.0.0.1:8080/auth/realms/stottie",
    "aud": "apiman",
    "sub": "de4af322-85b2-4dbe-8d53-6a2ee29e4080",
    "azp": "apiman",
    "session_state": "69974623-be8b-49d7-840a-0330c6bdde21",
    "client_session": "b5bd36a0-d576-4593-be7b-4648612c25b8",
    "allowed-origins": [],
    "realm_access": {
        "roles": [
            "echomeister"
        ]
    },
    "resource_access": {
        "account": {
            "roles": [
                "view-profile",
                "manage-account"
            ]
        }
    },
    "name": "",
    "preferred_username": "rincewind"
}
```

This demonstrates one OAuth2's most useful attributes: all the information required to validate a request is contained within the token itself.

=== Apiman OAuth2 Policy

First, log into apiman, and *Create a New Organization*; let's call it *_Newcastle_*. Select the *Services* tab, and add a *New Service*; we'll name this one *_EchoService_* and then *Create Service*.

Select the *Implementation* tab, and set the endpoint to our echo service, `http://localhost:8080/apiman-echo`. Save and move onto the *Plans* tab, where you should opt to *Make this service public*. After saving, we can move onto the *Policies* tab, where the interesting stuff starts.

Navigate to *Add Policy*, and select *Keycloak OAuth Policy* from the drop-down list. A substantial set of options are available for your perusal, but for the purposes of this blog demo we'll set the following:

[cols="3*", options="header"]
|===
|Option
|Value
|Details

|Realm
|http://127.0.0.1:8080/auth/realms/stottie

|The path to our realm footnote:[Ensure you use whatever the valid ISS value is for your Keycloak realm. One quick way to find this is by decoding an access_token looking at what Keycloak has set for the `iss` field]. Note that in older versions of Keycloak (pre `1.2.0`), the realm will just be the *stottie* (no path).

|Keycloak Realm Certificate
|Base64 encoded cert
|Paste your http://localhost:8080/auth/admin/master/console/#/realms/stottie/keys-settings[Keycloak realm certificate].

|Forward Authorization Roles
|Forward Realm Roles, and set _Forward Realm Roles?_ to *true*
|If we decide to use the authorization policy later, we'll forward the realm roles contained within the token (i.e. `echomeister`). If we don't need the granularity of roles, you can still just validate the token.

|===

Select *Add Policy*, and then *Publish* the service. You can see its endpoint information in the *Endpoint* tab, it should be similar to:

https://localhost:8443/apiman-gateway/Newcastle/EchoService/1.0

== Testing Authentication

Let's test our setup with cURL to see whether our request is _denied_ if we don't use a token:

```ShellSession
[msavy@mmbp tmp]$ curl -k  https://127.0.0.1:8443/apiman-gateway/Newcastle/EchoService/1.0
{
    "type": "Authentication",
    "failureCode": 11005,
    "responseCode": 401,
    "message": "OAuth2 'Authorization' header or 'access_token' query parameter must be provided.",
    "headers": {}
}
```

Excellent, it all seems to be working! Notice that we're using self-signed certificates for this demo, so the `-k` flag will skip certificate validation.

Next, let's do a request with a token. There are two ways to attach your bearer token to a request. Either:

- `Authorization` header, as `Authorization: Bearer <token>`
- `access_token` query parameter, as `http://example.org/the/path/?access_token=<token>`

First, let's retrieve a fresh token from Keycloak, and extract the `access_token` field from the json using `jq` footnote:[We're going to use `jq` to select the `access_token` field in our JSON, so if you don't have `jq` installed you can use your package manager to get it: OS X Brew `brew install jq`; On Fedora `sudo yum install jq`; On Debian `sudo apt-get install jq`].

```
curl -X POST http://127.0.0.1:8080/auth/realms/stottie/protocol/openid-connect/token  -H "Content-Type: application/x-www-form-urlencoded" -d 'username=rincewind' -d 'password=apiman' -d 'grant_type=password' -d 'client_id=apiman' | jq -r '.access_token'
```

Second, we'll take the token and attach it to our request to the service

```
[msavy@mmbp tmp]$ curl -k -H "Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiJiNDY1YW..." https://127.0.0.1:8443/apiman-gateway/Newcastle/EchoService/1.0
{
  "method" : "GET",
  "resource" : "/apiman-echo",
  "uri" : "/apiman-echo",
  "headers" : {
    "Authorization" : "Bearer eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiJiNDY1YWMzNi1hMTczLTRjOWMtYWJjZS00MzE2MJ...",
    "Host" : "127.0.0.1:8080",
    "User-Agent" : "curl/7.37.1",
    "Accept" : "*/*",
    "Connection" : "keep-alive",
    "Cache-Control" : "no-cache",
    "Pragma" : "no-cache"
  },
  "bodyLength" : null,
  "bodySha1" : null,
  "counter" : 1
}
```

Great, it worked! We can see EchoService has now been reached, meaning our OAuth2 token was validated successfully, and it sent us back a response which includes the bearer token we used (you can strip this out in the options).

If you're feeling lazy, here's https://gist.github.com/msavy/9390bfcd497f3c683a1c[an all-in-one script] to do it for you.

== Adding Authorization

We're going to develop our example a little bit further. At present, we simply have a binary approach where we either allow or disallow based upon which realm the token was issued from. If we want a more granular approach where we can discriminate upon roles, then we need to add another element: *Authorization*.

The more observant readers will note that we have already added two of the required elements when we imported the realm into Keycloak; namely, a user `rincewind` and a realm role `echomeister`.

If we navigate back to the *EchoService* service in the apiman UI, we can create a *New Version*. We'll call it *_2.0_* and clone the previous configuration. Moving over to the *Policies* tab again, we *Add Policy* and select *Authorization Policy* from the drop-down.

We're going to add two rules:

[cols="33a,33a,33a", options="header"]
|===
|To access resource
|using verb/action
|the user must have role

|`/rincewind/.*`
|`*`
|echomeister

|`/secret/.*`
|`*`
|overlord

|===

Our example user has the first role, but not the second. *Add* the policy and *Publish* the service again. Our endpoint will now reflect the changed version.

You will probably need to issue a new bearer token, which you can achieve by repeating the previous shell command.

```ShellSession
[msavy@mmbp tmp]$ curl -k -H "Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiJmODAyZjFmMy1kN2JmLTQ0YjQtODA2N..." \
 https://127.0.0.1:8443/apiman-gateway/Newcastle/EchoService/2.0/rincewind/wizard
{
  "method" : "GET",
  "resource" : "/apiman-echo/rincewind/wizard",
  "uri" : "/apiman-echo/rincewind/wizard",
  "headers" : {
    "Authorization" : "Bearer eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiJmODAyZjFmMy1kN2JmLTQ0YjQtODA2N...",
    "Host" : "127.0.0.1:8080",
    "User-Agent" : "curl/7.37.1",
    "Accept" : "*/*",
    "Connection" : "keep-alive",
    "Cache-Control" : "no-cache",
    "Pragma" : "no-cache"
  },
  "bodyLength" : null,
  "bodySha1" : null,
  "counter" : 19
}
```

As our user `rincewind` has the role `echomeister`, his request went through successfully.

However, if we try to access a resource for which he doesn't hold the appropriate role, we see an error message:

```ShellSession
[msavy@mmbp tmp]$ curl -k -H "Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJqdGkiOiJmODAyZjFmMy1kN2JmLTQ0YjQtODA2N..." \
 https://127.0.0.1:8443/apiman-gateway/Newcastle/EchoService/2.0/secret/not/allowed

{
    "type": "Authorization",
    "failureCode": 10009,
    "responseCode": 0,
    "message": "The user is not authorized to make this request (a required role is missing).",
    "headers": {}
}
```

== In Conclusion...

We protected an apiman service using OAuth2; with examples of both simple authentication and role-based authorization. It should be easy to design your own role-based auth setups in combination with Keycloak.
