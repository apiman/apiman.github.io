---
layout: post
title:  "Cover yourself up! Protecting your services with mutual auth"
date:   2015-06-04 12:50:45 +1
author: Marc Savy
categories: gateway security mutual-auth ssl mtls
---

The last thing you want after carefully setting up your system with apiman is for someone to be able to call around the gateway and hit your services directly. The typical solution for this is to lock down your network so that the only publicly accessible part is the apiman gateway, whilst services are hidden in the private part of the network, which apiman can access, but not someone in the outside world. However, in some situations fine-grained network controls may not be available, such as the cloud; or, you may wish to have an additional layer of security to be reassured that no funny business is going on (such as imposters).

The broad class of solutions to this problem generally fall under the banner of **mutual authentication**. One such mutual auth solution that apiman offers is Mutually Authenticated TLS.footnote:[Also commonly referred to as MTLS, MSSL, 2WAY, client authenticated TLS/SSL, two-way SSL, amongst other names!].

////
Use this pattern to avoid asciidoctor rendering the HTML comment.
<!--more-->
////

== What is mutual transport layer security (Mutual TLS)?

Most developers are familiar with SSL/TLS; it facilitates authentication via certificates followed by the establishment of an encrypted channel between the parties. It is overwhelmingly used in a one-way configuration: the client (often a browser) connects to a server, inspects the certificates it presents, and makes a determination as to whether the server is trustworthy. The connection is only made if the client is satisfied that the server is who it claims to be. In general, the server makes no determination as to who the client is.

However, in a typical apiman setup where the gateway is acting the client and the services.footnote:[We refer to the set of APIs managed by apiman as services] act as the servers. Clearly, if we wish to prevent anyone other than approved clients from connecting directly to our services then unidirectional authentication is insufficient: we must ascertain the identities of _both_ client and server before establishing a connection. In essence, each parties must present certificates that the other party trusts. This a great way to prevent anyone from side-stepping our gateway, and even better, it also stops any interlopers from sneaking into the system.

Luckily, apiman makes this http://www.apiman.io/latest/installation-guide.html#_how_to_enable_mtls_mutual_ssl_support_for_endpoint_security[extremely easy to set this up], so let's dive in and explore what's possible.

== Architecture

Let's assume 'node' refers generically to a participant in our system, either a gateway or a service.

There are two main elements we need to work with: *keystores*, which contain a node's private key material, and *truststores*, which contain public certificates instructing the node who it should trust.

Ideally, each node should have its own keystore, whose key material should be signed by a *trusted certificate authority*; a trusted party whose signature indicates that the holder of the certificate is trustworthy. In many organisations there is an internal certificate authority which will sign or issue certificates. If we add a CA's certificate to our node's keystores, then _any_ certificate issued by it will be trusted by virtue of the issuer's authority. This approach scales excellently, because we can issue an unlimited number of new certificates without needing to add them to our truststores.

It bears mentioning that any applications.footnote:[Users of our services, like browsers, mobile apps, etc] legitimately using our gateway will never be exposed to any mutual auth issues; they will establish a standard one-way TLS connection that is terminated at the gateway, with the gateway then establishing the two-way TLS connection to the service.

["plantuml", "asciidoctor-diagram-classes", "svg"]
---------------------------------------------------------------------
class BlockProcessor
class DiagramBlock
class DitaaBlock
class PlantUmlBlock

BlockProcessor <|-- DiagramBlock
DiagramBlock <|-- DitaaBlock
DiagramBlock <|-- PlantUmlBlock
---------------------------------------------------------------------
