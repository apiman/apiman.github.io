<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Crash Course in Apiman 1.5.3.Final</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL-NS Stylesheets V1.74.0"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div class="book" lang="en-US"><div class="titlepage"><div><p xmlns:d="http://docbook.org/ns/docbook" id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e3"/>Crash Course in Apiman 1.5.3.Final</h1></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#d0e9"/></span></dt><dt><span class="chapter"><a href="#_introduction">1. Introduction</a></span></dt><dt><span class="chapter"><a href="#_section_1_how_apiman_works">2. Section 1 - How apiman Works</a></span></dt><dd><dl><dt><span class="section"><a href="#_the_apiman_data_model">2.1. The apiman Data Model</a></span></dt><dt><span class="section"><a href="#_apiman_at_runtime_proxying_requests">2.2. Apiman at Runtime - Proxying Requests</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_section_2_policies_the_core_of_api_management">3. Section 2 - Policies, the Core of API Management</a></span></dt><dd><dl><dt><span class="section"><a href="#_what_s_in_a_policy">3.1. What’s in a Policy</a></span></dt><dt><span class="section"><a href="#_security_policies_authentication_authorization">3.2. Security Policies - Authentication &amp; Authorization</a></span></dt><dt><span class="section"><a href="#_limiting_policies_rates_and_quotas">3.3. Limiting Policies - Rates and Quotas</a></span></dt><dt><span class="section"><a href="#_other_policies">3.4. Other Policies</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_section_3_providing_apis">4. Section 3 - Providing APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#_publishing_apis">4.1. Publishing APIs</a></span></dt><dt><span class="section"><a href="#_security_for_apis_policy_and_endpoint_security">4.2. Security for APIs - Policy and Endpoint Security</a></span></dt><dd><dl><dt><span class="section"><a href="#_policy_level_security">4.2.1. Policy Level Security</a></span></dt><dt><span class="section"><a href="#_endpoint_level_security">4.2.2. Endpoint Level Security</a></span></dt></dl></dd><dt><span class="section"><a href="#_api_metrics">4.3. API Metrics</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_section_4_consuming_apis">5. Section 4 - Consuming APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#_invoking_managed_apis">5.1. Invoking Managed APIs</a></span></dt><dt><span class="section"><a href="#_managing_client_applications_and_contracts">5.2. Managing Client Applications and Contracts</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_section_5_managing_apiman">6. Section 5 - Managing apiman</a></span></dt><dd><dl><dt><span class="section"><a href="#_users_and_roles">6.1. Users and Roles</a></span></dt><dd><dl><dt><span class="section"><a href="#_understanding_ootb_apiman_user_roles">6.1.1. Understanding OOTB apiman user roles</a></span></dt><dt><span class="section"><a href="#_creating_a_new_user_role_defining_the_role_permissions">6.1.2. Creating a New User Role/Defining the Role Permissions</a></span></dt></dl></dd><dt><span class="section"><a href="#_managing_policies_and_plugins">6.2. Managing Policies and Plugins</a></span></dt><dt><span class="section"><a href="#_managing_gateways">6.3. Managing Gateways</a></span></dt><dt><span class="section"><a href="#_apiman_rest_api">6.4. Apiman REST API</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_section_6_getting_up_and_running_with_apiman_in_10_minutes">7. Section 6 - Getting Up and Running with apiman in 10 minutes</a></span></dt><dd><dl><dt><span class="section"><a href="#_prerequisite_software_required">7.1. Prerequisite Software Required</a></span></dt><dt><span class="section"><a href="#_getting_the_bits_downloading_apiman">7.2. Getting the Bits - Downloading apiman</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_section_7_apiman_resources">8. Section 7 - Apiman Resources</a></span></dt></dl></div><div class="preface" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e9"/></h2></div></div></div><p>A Crash Course in API Management with JBoss apiman</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_introduction"/>Chapter 1. Introduction</h2></div></div></div><p>Welcome to the crash course in JBoss apiman! The goal of this crash course is to provide a short and easy to consume introduction to API Management with apiman. This crash course will explain how apiman works and will walk you through a hands-on session to demonstrate how to use it. This crash course also provides links to the extensive on-line apiman user documentation, demos and quickstarts, and other resources.</p><p>This crash course is organized into the following sections:</p><div class="itemizedlist"><ul><li>How apiman Works - This section describes the data model apiman uses, and how it uses the elements created in that data model to perform its tasks.</li><li>Policies: At the Core of API Management - In API Management, policies are where the action is. It’s the policies that define the rules that apiman uses to manage your APIs. Since policies are so important, this is the longest section of the crash course.</li></ul></div><p>Each of the next four sections in the crash course describes how apiman supports the four primary groups of apiman users:</p><div class="itemizedlist"><ul><li>Providing APIs - This section describes how API providers can use apiman to publish APIs and summarizes management options for those APIs.</li><li>Consuming APIs - And this section describes how their counterparts, consumers of APIs, utilize apiman.</li><li>Managing apiman - This section describes the major tasks that are performed by apiman administrators.</li><li>Developing for apiman - And, this section describes how apiman supports the development of extensions and customizations.</li></ul></div><p>Each of the last two sections in the crash course provides step-by-step descriptions of how to use apiman to:</p><div class="itemizedlist"><ul><li>Install, configure and get apiman running for API providers and API consumers in 10 minutes.</li><li>Utilize apiman’s REST interface to automate tasks.</li></ul></div><p>Let’s get started!</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_section_1_how_apiman_works"/>Chapter 2. Section 1 - How apiman Works</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#_the_apiman_data_model">2.1. The apiman Data Model</a></span></dt><dt><span class="section"><a href="#_apiman_at_runtime_proxying_requests">2.2. Apiman at Runtime - Proxying Requests</a></span></dt></dl></div><p>The (4) primary groups of apiman users are:</p><div class="itemizedlist"><ul><li>API Providers</li><li>API Consumers</li><li>API Management Administrators</li><li>API Developers</li></ul></div><p>Apiman fulfills these groups of users' needs by providing these subsystems:</p><div class="itemizedlist"><ul><li>API Manager - The API Manager provides an easy way for API providers to use a web UI to define plans for their APIs, apply these plans across multiple APIs, and control role-based user access and API versioning. These plans can govern access to APIs and limits on the rate at which consumers can access APIs. The same UI enables API consumers to easily locate and access APIs.  All features available in the web UI are also available via a REST interface, allowing full automation.</li><li>API Gateway - The gateway applies the policies configured in the API Manager, enforcing them as runtime rules for each managed API request made.  The way that the API Gateway works is that the consumer of the API accesses the API through a URL that designates the API Gateway as a proxy for the API. If the policies defined to govern access to the API permit that access, the API Gateway then proxies requests to the backend API implementation.</li><li>An Extensible Plugin-Based Architecture - API Developers can create their own custom API management policies and install them into apiman.  In addition, custom implementations of core apiman components can be created and used, without needing to rebuild the core system.</li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_the_apiman_data_model"/>2.1. The apiman Data Model</h2></div></div></div><p>Apiman uses a hierarchical data model that consists of the following primary elements:</p><div class="itemizedlist"><ul><li>Organizations</li><li>Plans</li><li>APIs</li><li>Client Apps</li><li>Policies</li></ul></div><p><span class="inlinemediaobject"><img src="images/images/apiman_001.png" alt="apiman data model"/></span></p><div class="itemizedlist"><ul><li><span class="strong"><strong>Policies</strong></span> - Policies are at the lowest level of the data model, but they are arguably the most important concept because they represent the unit of work done at runtime (when the API Gateway applies the policies to all API requests). Everything defined in the API Manager is there to enable apiman to apply policies to requests made to APIs. When a request to an API is made, apiman creates a chain of policies to be applied to that request. Apiman policy chains define a specific sequence order in which the policies defined in the API Manager UI are applied to API requests. You can think of a policy as a rule, or set of rules that are enforced by the API Gateway. There are multiple types of apiman policies. Some policies allow or block access to APIs based on the IP address of the client application, while others allow or restrict access to specific resources provided by an API, while still others enable you to control or “throttle” the rate at which requests made to an API.</li><li><span class="strong"><strong>Plans</strong></span> - In apiman, a Plan is a set policies that together define the level of service that apiman provides for an API. Plans enable apiman users to define multiple different levels of service for their APIs. It’s common to define different plans for the same API, where the differences depend on configuration options. For example, an organization may offer both a “gold” and “silver” plan for the same API. The gold plan may be more expensive than the silver plan, but it may offer a higher level of API requests in a given (and configurable) time period.</li><li><span class="strong"><strong>APIs</strong></span> - These represent real back-end APIs that are being “managed” by apiman.  An API can either be Public (available to any invoker at a static endpoint) or Private (only invokable by Client Apps that are modeled within apiman).  This is the primary entity that an API Provider is responsible for editing within the API Manager.</li><li><span class="strong"><strong>Client Apps</strong></span> - A Client App represents a piece of software that needs to consume managed APIs that are offered through apiman.  Each Client App can consume multiple APIs within apiman by creating a contract to the API through one of its Plans.  This is the primary entity that an API Consumer is responsible for editing within the API Manager.</li><li><span class="strong"><strong>Organizations</strong></span> - The Organization is at the top level of the apiman data model. An organization contains and manages all elements used by a company, university, group inside a company, etc. for API management with apiman. All Plans, APIs,and Client Apps are defined in an apiman organization. In this way, an organization acts as a container of other elements. Users must be associated with an organization before they can use apiman to manage elements within it. Apiman implements role-based access controls for users. The organization membership role assigned to a user defines the actions that a user can perform and the elements that a user can manage within the organization.</li></ul></div><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>In the apiman data model, almost everything exists in the context of an organization.</p></div><p>Note that the apiman data model supports versioning for many of its data elements. Versioning enables you to retain and make use of multiple versions of data elements such as APIs and plans.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_apiman_at_runtime_proxying_requests"/>2.2. Apiman at Runtime - Proxying Requests</h2></div></div></div><p>What happens is that when an API request is received by the API Gateway at runtime, the policy chain is applied in the order of client app, plan, and API. If no failures, such as a rate counter being exceeded, occur, the API Gateway sends the request to the API. In order to be accepted by the API Gateway, a request must include an API key. The API Gateway acts as a proxy for the API:</p><p><span class="inlinemediaobject"><img src="images/images/apiman_002.png" alt="apiman at runtime"/></span></p><p>Next, when the API Gateway receives a response from the API’s backend implementation, the policy chain is applied again, but this time in the reverse order. The API policies are applied first, then the plan policies, and finally the client app policies. If no failures occur, then the API response is sent back to the consumer of the API.</p><p>Before we move on, it’s important that we’re clear on some basic terminology. When we talk about an API that is <span class="emphasis"><em>managed</em></span> by apiman (in other words, a <span class="emphasis"><em>managed API</em></span>), we’re referring to an an API where the apiman API Gateway is acting as a proxy. In order to able access a managed API, a client app must make of of an <span class="emphasis"><em>API key</em></span> that is generated when the API is published to the API Gateway. The API key is embedded in the URL at which the managed API is published by the API Gateway. We’ll see a working example of this later in the crash course.</p><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>From a client app’s perspective, the only difference between accessing a managed API and another API is the format of the APIs' endpoint URL.</p></div><p>The sequence in which incoming API requests have policies applied is:</p><div class="itemizedlist"><ul><li>First, at the client app level. In apiman, a client app is contracted to use one or more APIs.</li><li>Second, at the plan level. In apiman, policies can be organized into groups called plans.</li><li>Third, at the individual API level.</li></ul></div><p>By applying the policy chain twice, both for the originating incoming request and the resulting response, apiman allows policy implementations two opportunities to provide management functionality during the lifecycle. The following diagram illustrates this two-way approach to applying policies:</p><p><span class="inlinemediaobject"><img src="images/images/apiman_003.png" alt="policy ordering"/></span></p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_section_2_policies_the_core_of_api_management"/>Chapter 3. Section 2 - Policies, the Core of API Management</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#_what_s_in_a_policy">3.1. What’s in a Policy</a></span></dt><dt><span class="section"><a href="#_security_policies_authentication_authorization">3.2. Security Policies - Authentication &amp; Authorization</a></span></dt><dt><span class="section"><a href="#_limiting_policies_rates_and_quotas">3.3. Limiting Policies - Rates and Quotas</a></span></dt><dt><span class="section"><a href="#_other_policies">3.4. Other Policies</a></span></dt></dl></div><p>Policies are the most important element of API management. All the subsystems in apiman, from the Management API UI to the API Gateway, exist for one ultimate goal; to ensure that API governance is achieved by the application of policies to API requests. In apiman, policies are applied through a policy chain.  Apiman is not only preconfigured with a rich set of policies that you can use, right out of the box, it also supports a mechanism that you can use to define your own custom policies.</p><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>API governance is achieved by the API Gateway applying policies to API requests.</p></div><p>Apiman has support for many policies, including (but not limited to):</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th align="left" valign="top">Policy Categories</th><th align="left" valign="top">Policies</th></tr></thead><tbody><tr><td align="left" valign="top"><p>Security Policies</p></td><td align="left" valign="top"><div class="itemizedlist"><ul><li><span class="strong"><strong>BASIC Authentication</strong></span> - A username/password is required to access an API.</li><li><span class="strong"><strong>OAuth Authentication</strong></span> - Uses Keycloak to provide OAuth authentication.</li><li><span class="strong"><strong>Authorization</strong></span> - Access to APIs’ resources is controlled by user roles.</li><li><span class="strong"><strong>IP Blacklist</strong></span> - Clients with specific IP address will be blocked from accessing an API.</li><li><span class="strong"><strong>IP Whitelist</strong></span> - And, clients with specific IP address will not be blocked from accessing an API.</li><li><span class="strong"><strong>Ignored Resources</strong></span> - Paths to APIs’ resources that will not be accessible.</li><li><span class="strong"><strong>Time Restricted Access</strong></span> - Specify when an API can be accessed.</li><li><span class="strong"><strong>URL Whitelist</strong></span> - Allow only specific sub-resources to be accessed.</li></ul></div></td></tr><tr><td align="left" valign="top"><p>Limiting Policies</p></td><td align="left" valign="top"><div class="itemizedlist"><ul><li><span class="strong"><strong>Rate Limiting</strong></span> - Access to an API is limited by the number of requests in a defined time period (generally used to create a fine-grained limit).</li><li><span class="strong"><strong>Quota</strong></span> - Access to an API is limited by the number of requests in a defined time period (generally used to create a coarse-grained limit).</li><li><span class="strong"><strong>Transfer Quota</strong></span> - Similar to a Quota policy, but based on the number of bytes transferred, not the number of requests.</li></ul></div></td></tr><tr><td align="left" valign="top"><p>Modification Policies</p></td><td align="left" valign="top"><div class="itemizedlist"><ul><li><span class="strong"><strong>URL Rewriting</strong></span> - Modify any URLs in the API response so that they direct users through the API Gateway rather than directly to the back-end API.</li><li><span class="strong"><strong>Transformation</strong></span> - Used to convert between JSON and XML.</li><li><span class="strong"><strong>JSONP</strong></span> - Can convert a standard JSON API into a JSONP endpoint.</li><li><span class="strong"><strong>Simple Header</strong></span> - Used to make custom changes to the request and/or response headers (add, remove, modify).</li></ul></div></td></tr><tr><td align="left" valign="top"><p>Other Policies</p></td><td align="left" valign="top"><div class="itemizedlist"><ul><li><span class="strong"><strong>Caching</strong></span> - Cache results from a backend API.</li><li><span class="strong"><strong>Logging</strong></span> - Log all request/response headers for each request.</li></ul></div></td></tr></tbody></table></div><p>Let’s learn a little bit more about policies.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_what_s_in_a_policy"/>3.1. What’s in a Policy</h2></div></div></div><p>An apiman policy consists of the following:</p><div class="itemizedlist"><ul><li>Basic meta-data about the policy (name, description)</li><li>JSON based configuration</li><li>A Java class providing the implementation of the policy</li></ul></div><p>Each policy supported by apiman performs a specific task, such as (but not limited to):</p><div class="itemizedlist"><ul><li>Rate Limiting/Quotas</li><li>Security</li><li>Caching</li><li>Transformation</li></ul></div><p>Every API managed by apiman can be configured with zero or more policies.  In addition, an API can be offered for consumption through several Plans, where each Plan can be configured with zero or more policies.  Finally, a Client App can also be configured with a set of policies.  Whenever the API Gateway receives a request for an API (optionally on behalf of a specific Client App), it creates a chain of policies from those configured at the three levels, and then applies that chain of policies to the request.</p><p>Most of the apiman policies work alone (e.g. caching), but some of them are used in conjunction with other policies.  The next couple of sections will discuss two very common categories of policies, some of the policies found in those categories, and how they work together.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_security_policies_authentication_authorization"/>3.2. Security Policies - Authentication &amp; Authorization</h2></div></div></div><p>We’ll start with the Authorization and Authentication policies. We’ll review these policies together as the use of the Authorization type depends on the BASIC authentication type. Before we take a detailed look at the policies supported by apiman, it’s important that we understand the differences between authentication and authorization:</p><div class="itemizedlist"><ul><li>In authentication-based policies, access to an API is governed by the identity of the user</li><li>In authorization-based policies, access to an API, or specific resources provided by an API is governed by the role(s) assigned to a user</li></ul></div><p>In order to make use of an authorization policy, roles must be extracted during authentication. In other words, you cannot have authorization without authentication.</p><p>APIs often define security requirements to ensure that clients have to authenticate. By having apiman perform this authentication, backend APIs are freed from having to implement and perform this authentication. This also has the added benefit of centralizing the authentication for all your APIs.</p><p>In creating an Authentication policy, we define an Authentication Realm (think of this as an area to be protected, within which usernames and passwords exist) and an optional HTTP header. The HTTP header is used to optionally pass the authenticated user’s principal to the back-end API through an HTTP header. This is useful if the back-end system needs to know the username of the user calling it (e.g. to perform a user-specific operation).</p><p>An apiman Authorization policy consists of a set of rules. The rules define the resources that can be accessed in terms of a regular expression and an HTTP verb (GET, PUT, etc.)</p><p>Through its authorization policies, apiman enables you to create fine-grained rules to govern access to your API’s resources. For example, based on the user roles that you define, users assigned a “sales” role can access the sales related API resources, and users assigned a “marketing” role can access the marketing related API resources. Users assigned to to an “admin” role are able to access all the API’s resources.</p><p>As we mentioned a moment ago, in order to make use of an authorization policy, roles must be extracted during authentication. Apiman can be configured to extract those roles from an available source; for instance, the <a class="link" href="http://jwt.io/" target="">JSON Web Token</a> when using Keycloak, or JDBC/LDAP with the BASIC authentication policy in the API request. Remember, you cannot have authorization without authentication.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_limiting_policies_rates_and_quotas"/>3.3. Limiting Policies - Rates and Quotas</h2></div></div></div><p>Apiman provides (3) limiting policies:</p><div class="itemizedlist"><ul><li>Rate Limiting - This policy type governs the number of times requests are made to an API within a specified time period. The requests can be filtered by user, application, or API and can set the level of granularity for the time period to second, minute, hour, day, month, or year. The intended use of this policy type is 	for fine grained processing (e.g., 10 requests per second).</li><li>Quota - This policy type performs the same basic functionality as the Rate Limiting policy type., however, the intended use of this policy type is for less fine grained processing (e.g., 10,000 requests per month).</li><li>Transfer Quota - In contrast to the other policies, Transfer Quota tracks the number of bytes transferred (either uploaded or downloaded) rather than the total number of requests made.</li></ul></div><p>Each of these policies, if used singly, can be effective in throttling requests. Apiman, however, adds an additional layer of flexibility to your use of these policies by enabling you to use them in combinations. Let’s look at a few examples.</p><p>Limiting the total number of API requests within a period of time is a straightforward task and can be configured in a quota policy. This policy, however, may not have the desired effect as the quota may be reached early in the defined time period. If this happens, the requests made to the API during the remainder of the (typically long) time period will be blocked by the policy. A better way to deal with a situation like this is to implement a more flexible approach where the monthly quota policy is combined with a fine grained rate limiting policy that will act as a throttle on the traffic.</p><p>To illustrate, there are about 2.5 million seconds in a month. If we want to set the API request quota for a month to 1/2 million, then we can also set a rate limit policy to a limit of 5 requests per second to ensure that API requests are throttled and the API can be accessed throughout the entire month.</p><p>Here’s a visual view of a rate limiting policy based on a time period of one week. If we define a weekly quota, there is no guarantee that users will not consume that quota before the week is over. This will result in an API’s requests being denied at the end of the week. In contrast, if we augment the weekly quota with a more fine grained policy, we can maintain the API’s ability to respond to requests throughout the week:</p><p><span class="inlinemediaobject"><img src="images/images/apiman_004.png" alt="rate limiting"/></span></p><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>Policies can be configured to work together in combinations.</p></div><p>The ability to throttle API requests based on API request counts and bytes transferred provides even greater flexibility in implementing policies. APIs that transfer larger amounts of data, but rely on fewer API requests can have that data transfer throttled on a per byte basis. For example, an API that is data intensive, will return a large amount of data in response to each API request. The API may only receive a request a few hundreds of times a day, but each request may result in several megabytes of data being transferred. Let’s say that we want to limit the amount of data transferred to 6GB per hour. For this type of API, we could set a rate limiting policy to allow for one request per minute, and then augment that policy with a transfer quota policy of 100Mb per hour.</p><p>Before we move on, let’s look at how we can combine multiple policies into a plan.</p><p>It’s important to keep in mind that a plan can contain multiple policies. For our example, we’ll create both a “gold” plan and a “silver” plan. In a real-world situation, gold and silver level plans might look something like this:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td align="left" valign="top"><p>Gold plan</p></td><td align="left" valign="top"><div class="itemizedlist"><ul><li>A coarse grained Quota plan with a limit of 100,000 API requests per month, and a fine grained Rate Limiting plan of 100 service requests per minute</li></ul></div></td></tr><tr><td align="left" valign="top"><p>Silver plan</p></td><td align="left" valign="top"><div class="itemizedlist"><ul><li>A coarse grained Quota plan with a limit of 20,000 API requests per month, and a fine grained Rate Limiting plan of 500 service requests per minute</li></ul></div></td></tr></tbody></table></div><p>This diagram lets us visualize how the two policies will work together:</p><p><span class="inlinemediaobject"><img src="images/images/apiman_005.png" alt="policies working together"/></span></p><p>In this diagram,  each filled in box represents one API request. The important thing to understand is how the policies work together to enable you to have flexible throttling of requests to your API:</p><div class="itemizedlist"><ul><li>The fine grained rate limit is reset at  the end of the time period defined for the rate limit policy</li><li>And, the total number of API requests continue to be applied to the defined quota until the quota policy time limit is reached.</li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_other_policies"/>3.4. Other Policies</h2></div></div></div><p>There are many other policies offered by apiman, each of them performing a specific task.  And more policies are added with every release!  Even more interesting, you can add your own custom policies using apiman’s excellent plugin framework (more on that later).  You can refer to the apiman User Guide for a full list of official policies, what each policy does, and how to configure it.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_section_3_providing_apis"/>Chapter 4. Section 3 - Providing APIs</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#_publishing_apis">4.1. Publishing APIs</a></span></dt><dt><span class="section"><a href="#_security_for_apis_policy_and_endpoint_security">4.2. Security for APIs - Policy and Endpoint Security</a></span></dt><dd><dl><dt><span class="section"><a href="#_policy_level_security">4.2.1. Policy Level Security</a></span></dt><dt><span class="section"><a href="#_endpoint_level_security">4.2.2. Endpoint Level Security</a></span></dt></dl></dd><dt><span class="section"><a href="#_api_metrics">4.3. API Metrics</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_publishing_apis"/>4.1. Publishing APIs</h2></div></div></div><p>When an API is published to the API Gateway, the API is made available to the client apps that are the consumers of APIs. There are two different ways to publish an API:</p><p>Publishing an API as Public API - Public APIs can be directly accessed by any client, without providing an API Key. This allows you to distribute the URL that is used to access the API through through the API Gateway. The URL for a managed Public API takes this form:</p><pre class="screen">http://gatewayhostname:port/apiman-gateway/{organizationId}/{API ID}/{API version}/</pre><p>Public APIs are also very flexible in that they can be updated without being re-published. Unlike APIs published through Plans, Public APS can be accessed by a client app without requiring API consumers to agree to any terms and conditions related to a contract defined in a plan for the API.  It is also important to note that when an API is Public, only the policies configured on the API itself will be applied by the API Gateway.</p><p>Publishing an API through Plans - In contrast to Public APIs, these APIs, once published, must be accessed by a Client App via its API key.  In order to gain access to an API, the Client App must create a contract with an API through one of the API’s configured Plans.  Also unlike Public APIs, APIs that are published and accessed through its Plans, once published, cannot be changed. To make changes, new versions of these APIs must be created.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_security_for_apis_policy_and_endpoint_security"/>4.2. Security for APIs - Policy and Endpoint Security</h2></div></div></div><p>One important aspect of all APIs that are managed by the API Gateway is the security that the API Gateway provides.  Let’s next take a look at the different types of security that are available.</p><p>The authentication policy type provides username/password security for clients as they access the managed API through the API Gateway, but it does not protect the API from unauthorized access attempts that bypass the Gateway completely. To make the API secure from unauthorized client applications, endpoint level security should also be configured.</p><p>The best way to start our discussion of the different, but complementary types of security that we’ll examine in this article is with a diagram. The nodes involved are the client applications that will access our APIs, the apiman API Gateway, and the servers that host our APIs:</p><p><span class="inlinemediaobject"><img src="images/images/apiman_006.png" alt="apiman 006"/></span></p><p>Let’s work our way through the diagram from left to right and start by taking a look at Policy Level Security.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_policy_level_security"/>4.2.1. Policy Level Security</h3></div></div></div><p>Policy level security, such as that provided by an Authentication policy, secures the left side of the diagram, that is the communication channel between the applications and the API Gateway. In this communication channel, the applications play the role of the client, and the API Gateway plays the role of the server.</p><p>We also want to secure the right side of the diagram, where the API Gateway plays the role of a client, and the APIs play the role of the servers.</p><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>It’s worth noting that while policy security protects the managed API, it does nothing to protect the unmanaged API as this API can be reached directly, without going through the API Gateway. This is illustrated by the red line in the diagram. So, while access to the managed API through the apiman API Gateway is secure, policy security does not secure the unmanaged API endpoint.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_endpoint_level_security"/>4.2.2. Endpoint Level Security</h3></div></div></div><p>In contrast to policy level security, with endpoint security we are securing the right side of the diagram.  Current apiman supports two endpoint security options:</p><div class="itemizedlist"><ul><li>BASIC Authentication</li><li>MTLS (two-way SSL)</li></ul></div><p>A recent post by Marc Savy to the apiman blog <a class="link" href="http://www.apiman.io/blog/gateway/security/mutual-auth/ssl/mtls/2015/06/16/mtls-mutual-auth.html" target="">described how to configure Mutually Authenticated TLS</a> (Transport Layer Security) between the API Gateway and the managed APIs. With Mutual TLS, bi-direction authentication is configured so that the identities of both the client and server are verified before a connection can be made.</p><p>We should also note that, unlike policy security, endpoint security also secures the APIs from attempts to bypass the API Gateway. With Mutual TLS, a two-way trust pattern is created. The API Gateway trusts the APIs and the APIs trust the API Gateway. The APIs, however, do not trust the client applications. As is shown by the large “X” character that indicates that an application cannot bypass the API Gateway and access the APIs directly.</p><p>One last point that is important to remember is that the endpoint level of security applies to all requests made to the APIs, regardless of the policies configured.</p><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>Policy security alone does not secure an API’s unmanaged endpoints.</p></div><p>To summarize, the differences between policy level security and endpoint level security are:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th align="left" valign="top">Policy Level Security</th><th align="left" valign="top">End Point Level Security</th></tr></thead><tbody><tr><td align="left" valign="top"><p>Secures communications between the applications (clients) and API Gateway (server)</p></td><td align="left" valign="top"><p>Secures communications between the API Gateway (client) and APIs (servers)</p></td></tr><tr><td align="left" valign="top"><p>Configured in an API Gateway policy</p></td><td align="left" valign="top"><p>Configured for the API Gateway as a whole in apiman.properties and with key/certificates infrastructure</p></td></tr><tr><td align="left" valign="top"><p>Applied by a policy at runtime</p></td><td align="left" valign="top"><p>Enabled for all API requests, regardless of the policies configured for an API</p></td></tr><tr><td align="left" valign="top"><p>Does not secure the unmanaged API from access by unauthorized clients</p></td><td align="left" valign="top"><p>Secures the unmanaged API endpoints from access by unauthorized clients</p></td></tr></tbody></table></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_api_metrics"/>4.3. API Metrics</h2></div></div></div><p>After you’ve created and published your APIs, you will want to be able to keep track of the level of use they are receiving. To fulfill this need, apiman provides you with API metrics. The metrics track the following information:</p><div class="itemizedlist"><ul><li>Request start and end times</li><li>API start and end times (i.e. just the part of the request taken up by the back end API)</li><li>Resource path</li><li>Response type (success, failure, error)</li><li>API info (org id, id, version)</li><li>Client App info (org id, id, version)</li><li>Bytes uploaded/downloaded</li></ul></div><p>API Metrics can be accessed in the Management UI and through the REST API. The metrics are displayed visually in the Management UI, for example:</p><p><span class="inlinemediaobject"><img src="images/images/apiman_007.png" alt="metrics"/></span></p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_section_4_consuming_apis"/>Chapter 5. Section 4 - Consuming APIs</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#_invoking_managed_apis">5.1. Invoking Managed APIs</a></span></dt><dt><span class="section"><a href="#_managing_client_applications_and_contracts">5.2. Managing Client Applications and Contracts</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_invoking_managed_apis"/>5.1. Invoking Managed APIs</h2></div></div></div><p>From a client app’s perspective, the only difference between accessing a managed API and another API is the URL of the API’s endpoint. As we mentioned earlier in this crash course, a managed apiman endpoint takes this form:</p><pre class="screen">http://gatewayhostname:port/apiman-gateway/{organizationId}/{API ID}/{API version}/</pre><p>In addition, if the API is not Public, then the managed API endpoint must include a Client App’s API Key, either as a query parameter in the URL or as an HTTP header.  For example:</p><pre class="screen">http://localhost:8080/apiman-gateway/ACMEServices/echo/1.0?apikey=c374c202-d4b3-444206e3d</pre><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>Don’t panic! You don’t have to memorize the endpoint string. As we’ll see in a bit, the endpoint string is provided to you by apiman.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_managing_client_applications_and_contracts"/>5.2. Managing Client Applications and Contracts</h2></div></div></div><p>Public APIs can be consumed by any client. APIs that are not public can only be consumed by client applications that exist in an apiman organization and are registered with apiman.</p><p>When you create a client app in the Management UI, you are able to perform a search through all published APIs to locate the API that you want the client app to consume. The Management UI allows you to select from all published versions of an API, and from all the defined plans for an API. (Remember that, in this context, a plan is a set of policies that the API enforces.) Note that client apps can have configured policies, the same manner as plans and APIs.</p><p>Once you find an API that you want your client app to consume, and after you select the version of the API and the plan that you want to govern how your client app will consume the API, you use the Management UI to create an API contract. The contract contains the “Terms and Conditions” defined by the API provider that govern your client app’s use of the API.</p><p>Your client app can consume one or more API.  Once your client app has created contracts with all of the APIs it needs to consume, it must be registered with the Gateway.  This enables the Gateway to know which contracts are valid and how to create the full policy chain it will apply to the request.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_section_5_managing_apiman"/>Chapter 6. Section 5 - Managing apiman</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#_users_and_roles">6.1. Users and Roles</a></span></dt><dd><dl><dt><span class="section"><a href="#_understanding_ootb_apiman_user_roles">6.1.1. Understanding OOTB apiman user roles</a></span></dt><dt><span class="section"><a href="#_creating_a_new_user_role_defining_the_role_permissions">6.1.2. Creating a New User Role/Defining the Role Permissions</a></span></dt></dl></dd><dt><span class="section"><a href="#_managing_policies_and_plugins">6.2. Managing Policies and Plugins</a></span></dt><dt><span class="section"><a href="#_managing_gateways">6.3. Managing Gateways</a></span></dt><dt><span class="section"><a href="#_apiman_rest_api">6.4. Apiman REST API</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_users_and_roles"/>6.1. Users and Roles</h2></div></div></div><p>In the apiman data model, all data elements exist in the context of the organization. The same holds true for user memberships as users can be members of multiple organizations. Permissions in apiman are role based. The actions that a user is able to perform are dependent on the roles to which the user is assigned when she is added as a member of an organization.</p><p>Let’s start by looking at the roles that are preconfigured in apiman.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_understanding_ootb_apiman_user_roles"/>6.1.1. Understanding OOTB apiman user roles</h3></div></div></div><p>In apiman, each role defines a set of permissions granted by that role. When a user is made a member of an organization, that user must be assigned to a role. A role definition consists of a name and description, and, most importantly, a set of permissions that govern the user’s ability to view, edit, and administer the organization itself, as well as the organization’s plans, APIs, and applications.</p><p>Role Definitions are managed in the Roles section of the apiman System Administration section of the Management UI.</p><p>Apiman is preconfigured with the following roles:</p><div class="itemizedlist"><ul><li>Organization Owner</li><li>API Developer</li><li>Client App Developer</li></ul></div><p>These role names are self-explanatory. For example, a user assigned the Client App Developer role is able to manage the organization’s client apps but is blocked from managing its APIs or plans.</p><p>The full set of permissions provided in apiman by these preconfigured roles are:</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="left" valign="top">Preconfigured Role</th><th align="left" valign="top">Who Should be Assigned this Role</th><th align="left" valign="top">Permissions Granted by this Role</th></tr></thead><tbody><tr><td align="left" valign="top"><p>Client App Developer</p></td><td align="left" valign="top"><p>Users responsible for creating and managing client apps.</p></td><td align="left" valign="top"><div class="itemizedlist"><ul><li><span class="strong"><strong>Client App</strong></span> View, Edit, Admin</li></ul></div></td></tr><tr><td align="left" valign="top"><p>Organization Owner</p></td><td align="left" valign="top"><p>Automatically granted to the user who creates an Organization. Can be granted to other users by an existing Organization Owner.</p></td><td align="left" valign="top"><p>(all permissions)</p></td></tr><tr><td align="left" valign="top"><p>API Developer</p></td><td align="left" valign="top"><p>Users responsible for creating and managing APIs.</p></td><td align="left" valign="top"><div class="itemizedlist"><ul><li><span class="strong"><strong>Plan</strong></span> View, Edit, Admin</li><li><span class="strong"><strong>API</strong></span> View, Edit, Admin</li></ul></div></td></tr></tbody></table></div><p>Organization owners can assign roles to users through the <span class="emphasis"><em>Manage Members</em></span> form in the apiman Management UI (found off the <span class="emphasis"><em>Members</em></span> tab for an Organization). Each user must be assigned at least one role, but users can also be assigned multiple roles.</p><p>While apiman admin users can also modify the permissions as defined for these preconfigured roles, it is also very easy to create new custom roles.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="_creating_a_new_user_role_defining_the_role_permissions"/>6.1.2. Creating a New User Role/Defining the Role Permissions</h3></div></div></div><p>Custom roles give you the ability to exercise fine-grained control over the set of permissions granted to users.</p><p>Let’s look at an example of a custom role. Imagine a situation where you have API developer users and client app developer users. These sets of users can rely on apiman’s preconfigured roles. Let’s also imagine that you have a third set of user. You want these users to have read access to APIs and applications so that they can participate in a review/approval process. However, you do not want to give these users write access. You can create a view-only (read-only) role these users by configuring your custom Role Definition to only grant the Client App View and API View permissions.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_managing_policies_and_plugins"/>6.2. Managing Policies and Plugins</h2></div></div></div><p>Apiman is preconfigured with a core set of policies, but also supports adding more policies by installing one or more plugin.  There are a number of official apiman plugins which will enable additional policies to be configured.  Some examples of the official apiman plugin policies include (but are not limited to):</p><div class="itemizedlist"><ul><li>CORS - This plugin implements CORS (Cross-origin resource sharing): A method of controlling access to resources outside of an originating domain.</li><li>HTTP Security - Provides a policy which allows security-related HTTP headers to be set, which can help mitigate a range of common security vulnerabilities.</li><li>JSONP - A plugin that contributes a policy that turns a standard RESTful endpoint into a JSONP compatible endpoint.</li><li>Keycloak OAuth - This plugin offers an OAuth2 policy which leverages the Keycloak authentication platform as the identity and access provider.</li><li>Log Headers - Offers a simple policy that allows request headers to be added or stripped from the HTTP request (outgoing) or HTTP response (incoming).</li></ul></div><p>These optional plugins are accessed in the administrative page in the apiman Management UI.  You can install these policies as needed, and then uninstall them when they are no longer needed.</p><p>There are a couple of caveats to keep in mind when you uninstall a policy plugin:</p><div class="itemizedlist"><ul><li>First, uninstalling the plugin removes it from the apiman Management UI, but it still remains in use for all APIs in which it was previously configured.</li><li>Second, if you want to completely remove the plugin from all APIs in which it was previously configured, you must manually click on each API, Plan, and Client App that uses the policy and remove it. Apiman does not include a single “kill” button to automatically remove all references to a policy.</li></ul></div><p>In addition to enabling you to create and install your own custom policies, apiman also provides a mechanism to upgrade to new versions of those policies. This is an especially useful feature as, over time, a policy may be upgraded to include bug fixes or new features.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_managing_gateways"/>6.3. Managing Gateways</h2></div></div></div><p>When you install apiman, it’s configured with one API Gateway. Apiman, however, enables you to configure and use multiple API Gateways simultaneously. There are several reasons why you might want to configure multiple API Gateways:</p><div class="itemizedlist"><ul><li>It’s a good practice to maintain separate test and production environments for apiman. A test environment provides you with a safe place to experiment with the design of plans and custom policies without causing any interruption in service for APIs that are use for mission-critical production environments.</li><li>If some APIs are used more heavily than others, you might want to group these APIs and configure an API Gateway for them on higher performance servers, or base these APIs on API Gateways located in geographic locations closer to their highest use Client apps.</li></ul></div><p>Note that typically you will want to set up a single Gateway which is actually backed by multiple nodes/instances.  Each instance (e.g. running on WildFly) should be configured to use the same backing storage (e.g. Elasticsearch or JDBC).  This configuration results in a single “logical” gateway in apiman - so only one (1) gateway needs to be configured in the UI - when an API is published to one of the nodes, it will be available to them all.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_apiman_rest_api"/>6.4. Apiman REST API</h2></div></div></div><p>It’s inevitable that, after you work with a product’s UI for a while that you encounter tasks that are better suited to a scripting or batch interface. For example, if you have to perform a similar task for a large number of related data items, the time that it can require to perform these tasks through an interactive UI can be prohibitive. Also, it’s easy for repetitive tasks to become error prone as you can lose focus, even if you are working in a well designed and easy to use interface such as apiman.</p><p>One solution to this problem is to augment the UI with a command line or scripting interface. This can lead to a whole separate set of issues if the new interface is built on a different set of underlying routines than the UI. A better approach is to allow access to the same routines in which the UI is constructed. This approach removes any duplication, and also enables you to replicate manual UI based tasks with automated or scripted tools.</p><p>Apiman follows this second approach with its REST interface. All of the functionality provided by apiman in its Management UI are directly supported in the API Manager REST API  In fact, the UI simply makes calls to the REST layer in order to get data or make changes.</p><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>You can use the REST interface to automate any task that is performed in the UI.</p></div><p>The documentation for the apiman REST API is available (for free, of course), here: <a class="link" href="http://www.apiman.io/latest/api-manager-restdocs.html" target="">http://www.apiman.io/latest/api-manager-restdocs.html</a></p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_section_6_getting_up_and_running_with_apiman_in_10_minutes"/>Chapter 7. Section 6 - Getting Up and Running with apiman in 10 minutes</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#_prerequisite_software_required">7.1. Prerequisite Software Required</a></span></dt><dt><span class="section"><a href="#_getting_the_bits_downloading_apiman">7.2. Getting the Bits - Downloading apiman</a></span></dt></dl></div><p>In this section, we’ll also take a very hands-on look at apiman. In about 10 minutes, we’ll get apiman installed and running, define an API policy, create and publish an API, register an application, and watch apiman enforce that policy.</p><p>Let’s start by installing the prerequisite software packages that we will need.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_prerequisite_software_required"/>7.1. Prerequisite Software Required</h2></div></div></div><p>Like all JBoss middleware projects, you can run apiman on any operating system that supports Java software development. We don’t need very much in the way of prerequisite software to run apiman out of the box. (Note that there really isn’t a physical box as you can just download everything.)</p><p>What you will need to install to run apiman and follow all the steps in this chapter are:
 * Java - apiman can run Java version 1.8 or newer. You will want to install the full Java JDK. You can use either OpenJDK or Oracle’s JDK.
 * Apache Maven - While you do not need the maven build tool to run apiman, we will use it to build an example API. You should download and install maven version 3.3 or newer.</p><p>We don’t need very much to run apiman out of the box. Before we install apiman, you’ll have to have Java (version 1.8 or newer, in this section we’ll use Java 1.8) installed on your system. You’ll also need to install git and maven installed to be able to build the example API that we’ll use.</p><p>After you install the prerequisite software, the next thing we have to do is to get ourselves a copy of JBoss apiman.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_getting_the_bits_downloading_apiman"/>7.2. Getting the Bits - Downloading apiman</h2></div></div></div><p>To download apiman, open a browser and navigate to <a class="link" href="http://www.apiman.io" target="">http://www.apiman.io</a></p><p><span class="inlinemediaobject"><img src="images/images/example/1.png" alt="Apiman homepage"/></span></p><p>The phrase “running an apiman server” is a bit misleading, as apiman itself is not a server. apiman is distributed in multiple forms. We’ll examine and use each of these forms in this book:</p><div class="itemizedlist"><ul><li>apiman WildFly Overlay - In this distribution, apiman is packaged in a zip file that is installed over a JBoss WildFly (<a class="link" href="http://wildfly.org/" target="">http://wildfly.org/</a>) server.</li><li>Docker - In this distribution, apiman is packaged as Docker (<a class="link" href="https://www.docker.com/" target="">https://www.docker.com/</a>) images.</li></ul></div><p>We’ll keep things simple in this chapter and use the apiman WildFly Overlay distribution. (You can also download apiman packaged as a Docker image.)  If you navigate to the “downloads” page, you’ll see:</p><p><span class="inlinemediaobject"><img src="images/images/example/2.png" alt="Apiman Getting Started page"/></span></p><p>Let’s take a look at the contents of the WildFly Overlay. There are three main directories in the WildFly Overlay:</p><p>The apiman directory - This directory contains configuration data specific to apiman such as the DDL (Data Description Language) files that define database schemas used by apiman, JSON files that define policy and security settings, and a quickstart example program that we will use as an example API. The apiman directory is a new directory that is created when you unzip the WildFly Overlay file. The top level directories in the apiman directory look like this:</p><pre class="screen">├── apiman
│   ├── data
│   │   ├── all-policyDefs.json
│   │   └── apiman-realm.json
│   ├── ddls
│   │   ├── apiman_mysql5.ddl
│   │   └── apiman_postgresql9.ddl
│   ├── quickstarts
│   │   ├── echo-service
│   │   ├── LICENSE
│   │   ├── pom.xml
│   │   └── README.md
│   └── sample-configs
│       ├── apiman-ds_mysql.xml
│       └── apiman-ds_postgresql.xml</pre><p>The modules directory - This directory contains configuration files, including Keycloak (URL) configuration files that are added to the WildFly server for apiman. These files are added to the WildFly “standalone” server configuration . The top levels in this directory look like this:</p><pre class="screen">├── modules
│   └── system
│       └── layers
└── standalone
 ├── configuration
 │   ├── apiman.jks
 │   ├── apiman.properties
 │   ├── keycloak-server.json
 │   ├── providers
 │   ├── standalone-apiman.xml
 │   ├── standalone-keycloak.xml
 │   └── themes
 ├── data
 │   ├── es
 │   ├── h2
 │   └── keycloak.h2.db</pre><p>The deployments directory - This directory contains the apiman API Gateway, back end APIs, and apiman Management UI, packaged as .war files. By unzipping the WildFly Overlay file, these .war files are deployed to the WildFly server.  The top levels in this directory look like this:</p><pre class="screen">├── deployments
     ├── apiman-ds.xml
     ├── apiman-es.war
     ├── apiman-gateway-api.war
     ├── apiman-gateway.war
     ├── apimanui.war
     └── apiman.war</pre><p>Make a mental note of these apiman deployment files. We’ll see them again in a few minutes.</p><p>The apiman download page is here:  <a class="link" href="http://www.apiman.io/latest/download.html" target="">http://www.apiman.io/latest/download.html</a></p><p>The steps you follow are:</p><div class="itemizedlist"><ul><li>Download and Unzip the WildFly Server - Download <a class="link" href="http://download.jboss.org/wildfly/10.1.0.Final/wildfly-10.1.0.Final.zip" target="">http://download.jboss.org/wildfly/10.1.0.Final/wildfly-10.1.0.Final.zip</a>  and unzip the file into the directory in which you want to run the sever.</li><li>Download and Unzip the apiman WildFly overlay .zip file - Download the apiman WildFly overlay zip file into the directory that was created when you unzipped the WildFly download. The apiman WildFly overlay zip file is available here: <a class="link" href="http://downloads.jboss.org/apiman/1.5.3.Final/apiman-distro-wildfly10-1.5.3.Final-overlay.zip" target="">http://downloads.jboss.org/apiman/1.5.3.Final/apiman-distro-wildfly10-1.5.3.Final-overlay.zip</a>  After the file is downloaded, unzip it directly over the directory into which you unzipped the WildFly download. This will install apiman into the WildFly server.</li></ul></div><p>Installing apiman on an WildFly Server</p><p>The commands that you will execute to install the server will look something like this:</p><pre class="screen">mkdir ~/apiman-1.5.3.Final
cd ~/apiman-1.5.3.Final
curl http://download.jboss.org/wildfly/10.1.0.Final/wildfly-10.1.0.Final.zip -o wildfly-10.1.0.Final.zip
curl http://downloads.jboss.org/apiman/1.5.3.Final/apiman-distro-wildfly10-1.5.3.Final-overlay.zip -o apiman-distro-wildfly10-1.5.3.Final-overlay.zip
unzip wildfly-10.1.0.Final.zip
unzip -o apiman-distro-wildfly10-1.5.3.Final-overlay.zip -d wildfly-10.1.0.Final</pre><p>Before we move on, we have one server administration task to perform. We have to create a server user, so that we can log onto the server administrative console. This is necessary as WildFly does not come pre-installed with any users.</p><p>To create a new server user, navigate to this directory:</p><pre class="screen">cd apiman-1.5.3.Final/wildfly-10.1.0.Final/bin</pre><p>And execute this script:</p><pre class="screen">./add-user.sh</pre><p>When you are prompted for the type of user to create, select Management User:</p><p>What type of user do you wish to add?
a) Management User (mgmt-users.properties)
b) Application User (application-users.properties)
(a):</p><p>After you define a username and password, for the remainder of the prompts, you can safely take the default values, or select “yes” to complete the creation of a user account.</p><p>(Details on the administration of a WildFly server, including user management, are out of scope for this book as our focus is apiman. If you are interested in learning more about WildFly server administration, refer to the WildFly Server Administration Guide here: <a class="link" href="https://docs.jboss.org/author/display/WFLY10/Admin+Guide" target="">https://docs.jboss.org/author/display/WFLY10/Admin+Guide</a></p><p>Running the WildFly Server</p><p>To start the WildFly server, you navigate back to the directory into which you installed the server, execute these commands - note that in this context, “standalone” refers to a standalone (i.e., non-clustered) WildFly server.  You can learn more about WildFly server configuration options in the WildFly Server Administration Guide:</p><pre class="screen">cd apiman-1.5.3.Final/wildfly-10.1.0.Final
./bin/standalone.sh -c standalone-apiman.xml</pre><p>When the server starts, it will write logging messages (a lot of messages!) to the screen. The server will also create a server log file with these messages. When you see some messages that look like this, you’ll know that the server is up and running with apiman installed:</p><pre class="screen">"apiman-gateway.war")23:28:49,091 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0060: Http management interface listening on http://127.0.0.1:9990/management
23:28:49,091 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0051: Admin console listening on http://127.0.0.1:9990
23:28:49,091 INFO  [org.jboss.as] (Controller Boot Thread) WFLYSRV0025: WildFly Full 10.1.0.Final (WildFly Core 2.0.10.Final) started in 11891ms - Started 1131 of 1543 services (616 services are lazy, passive or on-demand)</pre><p>Testing the Installation</p><p>Congratulations! Your WildFly server is up and running with apiman installed!</p><p>Or is it?</p><p>Let’s take a quick look at how we can be sure that the server installation was correct. To do this, we’ll look in two places.</p><p>First, we’ll look at the WildFly Server Administrative Console.</p><p>Remember the user account that we created? We’ll use it now. To access the WildFly Server Administrative Console, open up a browser, and navigate to: <a class="link" href="http://localhost:8080" target="">http://localhost:8080</a></p><p>This page will be displayed:</p><p><span class="inlinemediaobject"><img src="images/images/example/3.png" alt="WildFly welcome page"/></span></p><p>When you select the Administration Console selection, you will be prompted for the username and password:</p><p><span class="inlinemediaobject"><img src="images/images/example/4a.png" alt="Prompting for credentials"/></span></p><p>Enter the username and password for the user that you defined (for this example, we used the very unimaginative and insecure username “admin”) and you will brought to the WildFly Server Administration Console:</p><p><span class="inlinemediaobject"><img src="images/images/example/4.png" alt="WildFly administration console"/></span></p><p>If you then select the “Deployments” tab at the top of the page, you’ll see the applications deployed to the server. This is where you should see the apiman deployments for the APIs, Gateway, and Management UI:</p><p><span class="inlinemediaobject"><img src="images/images/example/5.png" alt="WildFly deployments tab"/></span></p><p>If you don’t see the apiman deployments, don’t panic, but something went wrong with the installation. The most common reason for the apiman deployments to be missing is that you unzipped the apiman overlay .zip file into a different directory from the WildFly server. Remember, that the reason that the overlay file is named “overlay” is that it must be unzipped over an installed WildFly server. You can confirm that this is what happened by looking in the WildFly server’s deployment directory here:  wildfly-10.1.0.Final/standalone/deployments</p><p>If you look in this directory, you should see these files (the presence of files with the “.deployed” suffix indicates that the corresponding file was deployed successfully):</p><pre class="screen">apiman-ds.xml
apiman-ds.xml.deployed
apiman-es.war
apiman-es.war.deployed
apiman-gateway-api.war
apiman-gateway-api.war.deployed
apiman-gateway.war
apiman-gateway.war.deployed
apimanui.war
apimanui.war.deployed
apiman.war
apiman.war.deployed</pre><p>So, if you don’t see the apiman deployments, stop the server and start the installation over. Be careful to unzip the apiman overlay file directly over the directory created when you unzipped the WildFly server .zip file.</p><p>The second place we’ll look for evidence that the installation was successful is the WildFly server’s server.log file.</p><p>The WildFly server’s server.log file is created when the server is started. All the information that is displayed on the screen when you started the server is also written to the log file. (The level of detail written to the console and the log file is configurable. You can read about configuring WildFly logging here: <a class="link" href="https://docs.jboss.org/author/display/WFLY10/Admin+Guide" target="">https://docs.jboss.org/author/display/WFLY10/Admin+Guide</a>)</p><p>You can find the WildFly server file here: wildfly-10.1.0.Final/standalone/log/server.log</p><p>The WildFly server log file can be quite large as the server will append more logging statements to it over time. While you can certainly read the entire file anytime you want, we’ll focus on some highlights related to ensuring that the server started cleanly. An obvious first step is to search the file for logging statements written at the ERROR level. If the file does not contain any errors, you can look for statements that look like this to confirm that the server started cleanly:</p><pre class="screen">23:28:48,978 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 71) WFLYUT0021: Registered web context: /apiman-es
23:28:49,000 INFO  [org.jboss.as.server] (ServerService Thread Pool -- 36) WFLYSRV0010: Deployed "apiman-gateway-api.war" (runtime-name : "apiman-gateway-api.war")
23:28:48,999 INFO  [org.jboss.as.server] (ServerService Thread Pool -- 60) WFLYSRV0010: Deployed "keycloak-server.war" (runtime-name : "keycloak-server.war")
23:28:49,000 INFO  [org.jboss.as.server] (ServerService Thread Pool -- 36) WFLYSRV0010: Deployed "apiman.war" (runtime-name : "apiman.war")
23:28:49,000 INFO  [org.jboss.as.server] (ServerService Thread Pool -- 36) WFLYSRV0010: Deployed "apiman-es.war" (runtime-name : "apiman-es.war")
23:28:49,001 INFO  [org.jboss.as.server] (ServerService Thread Pool -- 36) WFLYSRV0010: Deployed "apiman-ds.xml" (runtime-name : "apiman-ds.xml")
23:28:49,001 INFO  [org.jboss.as.server] (ServerService Thread Pool -- 36) WFLYSRV0010: Deployed "apimanui.war" (runtime-name : "apimanui.war")
23:28:49,001 INFO  [org.jboss.as.server] (ServerService Thread Pool -- 36) WFLYSRV0010: Deployed "services.war" (runtime-name : "services.war")
23:28:49,001 INFO  [org.jboss.as.server] (ServerService Thread Pool -- 36) WFLYSRV0010: Deployed "authtest-ds.xml" (runtime-name : "authtest-ds.xml")23:28:49,001 INFO  [org.jboss.as.server] (ServerService Thread Pool -- 36) WFLYSRV0010: Deployed "apiman-gateway.war" (runtime-name :</pre><p>That’s right, it’s the same apiman deployment files. If you see statements like these, and there are no ERROR statements, then you should be able to safely access the WildFly Administration console.</p><p>There’s just more point we should cover before moving on. While the server may be up and running, it’s not really configured for production use. As a convenience, when you install apiman, it is preconfigured with a default administrator account. The username for this account is “admin” and the password is “admin123!” - not exactly a mission critical level of security!  If this were a production server, the first thing that we’d do is to change the default apiman admin username and password. apiman is configured by default to use JBoss KeyCloak (<a class="link" href="http://keycloak.jboss.org/" target="">http://keycloak.jboss.org/</a>) for password security. Also, the default database used by apiman to store contract and API information is the H2 in-memory database. For a production server, you’d want to reconfigure this to use a production database. We’ll cover apiman server security and production configuration settings in later chapters.</p><p>The Echo API “Quickstart”</p><p>The source code for the example service is contained in a git repo (<a class="link" href="http://git-scm.com" target="">http://git-scm.com</a>) hosted at github (<a class="link" href="https://github.com/apiman" target="">https://github.com/apiman</a>). To download a copy of the example service, navigate to the directory in which you want to build the service and execute this git command:</p><p>git clone <a class="link" href="mailto:git@github.com" target="">git@github.com</a>:apiman/apiman-quickstarts.git</p><p>As the source code is downloading, you’ll see output that looks like this:</p><pre class="screen">git clone git@github.com:apiman/apiman-quickstarts.git
Initialized empty Git repository in apiman-quickstarts/.git/
remote: Counting objects: 104, done.
remote: Total 104 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (104/104), 18.16 KiB, done.
Resolving deltas: 100% (40/40), done.</pre><p>The source code for the example API is provided in the wildfly-10.1.0.Final/apiman/quickstarts directory. (In JBoss software, the term “quickstart” refers to an example program.)</p><p>The echo-API quickstart includes these files:</p><p>And, after the download is complete, you’ll see a populated directory tree that looks like this:</p><pre class="screen">└── apiman-quickstarts
	├── echo-service
	│   ├── pom.xml
	│   ├── README.md
	│   └── src
	│   	└── main
	│       	├── java
	│       	│   └── io
	│       	│   	└── apiman
	│       	│       	└── quickstarts
	│       	│           	└── echo
	│       	│               	├── EchoResponse.java
	│       	│               	└── EchoServlet.java
	│       	└── webapp
	│           	└── WEB-INF
	│               	├── jboss-web.xml
	│               	└── web.xml
	├── LICENSE
	├── pom.xml
	├── README.md
	├── release.sh
	└── src
 	└── main
     	└── assembly
         	└── dist.xml</pre><p>As we mentioned earlier,  the example API is very simple. The only action that the API performs is to echo back in responses the meta data in the <a class="link" href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="">REST</a> requests that it receives.</p><p>Maven is used to build the API. To build the API into a deployable .war file, navigate to the directory into which you downloaded the API example:</p><pre class="screen">cd apiman-quickstarts/echo-service</pre><p>And then execute this maven command:</p><pre class="screen">mvn package</pre><p>As the API is being built into a .war file, you’ll see output that looks like this:</p><pre class="screen">[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building apiman-quickstarts-echo-service 1.2.4-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-resources-plugin:2.7:resources (default-resources) @ apiman-quickstarts-echo-service ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory  local/redhat_git/apiman-quickstarts/echo-service/src/main/resources
[INFO]
[INFO] --- maven-compiler-plugin:3.2:compile (default-compile) @ apiman-quickstarts-echo-service ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 2 source files to  local/redhat_git/apiman-quickstarts/echo-service/target/classes
[INFO]
[INFO] --- maven-resources-plugin:2.7:testResources (default-testResources) @ apiman-quickstarts-echo-service ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory  local/redhat_git/apiman-quickstarts/echo-service/src/test/resources
[INFO]
[INFO] --- maven-compiler-plugin:3.2:testCompile (default-testCompile) @ apiman-quickstarts-echo-service ---
[INFO] No sources to compile
[INFO]
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ apiman-quickstarts-echo-service ---
[INFO] No tests to run.
[INFO]
[INFO] --- maven-war-plugin:2.5:war (default-war) @ apiman-quickstarts-echo-service ---
[INFO] Packaging webapp
[INFO] Assembling webapp [apiman-quickstarts-echo-service] in [ local/redhat_git/apiman-quickstarts/echo-service/target/apiman-quickstarts-echo-service-1.2.4-SNAPSHOT]
[INFO] Processing war project
[INFO] Copying webapp resources [ local/redhat_git/apiman-quickstarts/echo-service/src/main/webapp]
[INFO] Webapp assembled in [37 msecs]
[INFO] Building war:  local/redhat_git/apiman-quickstarts/echo-service/target/apiman-quickstarts-echo-service-1.2.4-SNAPSHOT.war
[INFO]
[INFO] --- maven-source-plugin:2.4:jar-no-fork (attach-sources) @ apiman-quickstarts-echo-service ---
[INFO] Building jar:  local/redhat_git/apiman-quickstarts/echo-service/target/apiman-quickstarts-echo-service-1.2.4-SNAPSHOT-sources.jar
[INFO]
[INFO] --- maven-javadoc-plugin:2.10.1:jar (attach-javadocs) @ apiman-quickstarts-echo-service ---
[INFO]
Loading source files for package io.apiman.quickstarts.echo...
[INFO] Building jar:  local/redhat_git/apiman-quickstarts/echo-service/target/apiman-quickstarts-echo-service-1.2.4-SNAPSHOT-javadoc.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.061 s
[INFO] Finished at: 2016-04-16T22:13:10-04:00
[INFO] Final Memory: 26M/307M
[INFO] ------------------------------------------------------------------------</pre><p>If you look closely, near the end of the output, you’ll see the location of the .war file:</p><pre class="screen">local/redhat_git/apiman-quickstarts/echo-service/target/apiman-quickstarts-echo-service-1.2.4-SNAPSHOT.war</pre><p>To deploy the API, we can copy the .war file to our WildFly server’s deployments directory. After you copy the API’s .war file to the deployments directory, you’ll see output like this generated by the WildFly server:</p><pre class="screen">22:33:59,794 INFO  [org.jboss.as.repository] (DeploymentScanner-threads - 1) WFLYDR0001: Content added at location local/redhat_git/apiman/tools/server-all/target/wildfly-10.1.0.Final/standalone/data/content/31/f9a163bd92c51daf54f70d09bff518c2aeef7e/content
22:33:59,797 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-6) WFLYSRV0027: Starting deployment of "apiman-quickstarts-echo-service-1.2.4-SNAPSHOT.war" (runtime-name: "apiman-quickstarts-echo-service-1.2.4-SNAPSHOT.war")
22:33:59,907 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 76) WFLYUT0021: Registered web context: /apiman-echo
22:33:59,960 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 1) WFLYSRV0010: Deployed "apiman-quickstarts-echo-service-1.2.4-SNAPSHOT.war" (runtime-name : "apiman-quickstarts-echo-service-1.2.4-SNAPSHOT.war")</pre><p>Make special note of this line of output:</p><pre class="screen">22:33:59,907 INFO  [org.wildfly.extension.undertow] (ServerService Thread Pool -- 76) WFLYUT0021: Registered web context: /apiman-echo</pre><p>This output indicates that the URL of the deployed example API is:</p><p><a class="link" href="http://localhost:8080/apiman-echo" target="">http://localhost:8080/apiman-echo</a></p><p>Remember, however, that this is the URL of the deployed example API if we access it directly. We’ll refer to this as the "unmanaged API" as we are able to connect to the API directly, without going through the API Gateway.  The URL to access the API through the API Gateway ("the managed API") at runtime will be different.</p><p>Now that our example API is installed, it’s time to install and configure our client to access the server.</p><p>Accessing the Example API Through a Client</p><p>There are a lot of options available when it comes to what we can use for a client to access our API. We’ll keep the client simple so that we can keep our focus on apiman and simply use a browser as the client. If you enter the API’s URL into a browser, an HTTP GET command will be executed. The response will look like this:</p><pre class="screen">{
  "method" : "GET",
  "resource" : "/apiman-echo",
  "uri" : "/apiman-echo",
  "headers" : {
    "Cookie" : "s_fid=722D028B20E49214-13EAE1456E752098; __utma=111872281.807845787.1452188093.1460777731.1460777731.4; __utmz=111872281.1452188093.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _ga=GA1.1.807845787.1452188093; __qca=P0-404983419-1452188093717; __utmc=111872281",
    "Accept" : "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    "Connection" : "keep-alive",
    "User-Agent" : "Mozilla/5.0 (X11; Linux x86_64; rv:38.0) Gecko/20100101 Firefox/38.0",
    "Host" : "localhost:8080",
    "Accept-Language" : "en-US,en;q=0.5",
    "Accept-Encoding" : "gzip, deflate",
    "DNT" : "1"
  },
  "bodyLength" : null,
  "bodySha1" : null
}</pre><p>Now that our example API is built, deployed and running, it’s time to create the organizations for the API provider and the API consumer. The differences between the requirements of the two organizations will be evident in their apiman configuration properties.</p><p>OK, the preliminaries are over! Now, it’s time to go into the apiman Management UI and create the apiman data elements for our demonstration.</p><p>Creating Users for the API Provider and Consumer Organizations</p><p>Before we create the organizations, we have to create a user for each organization. We’ll start by creating the API provider user. To do this, logout from the admin account in the API Manager UI. The login dialog will then be displayed.</p><p><span class="inlinemediaobject"><img src="images/images/example/6.png" alt="Apiman realm login"/></span></p><p>Select the "New user/Register" Option and register the API provider user:</p><p><span class="inlinemediaobject"><img src="images/images/example/7.png" alt="Apiman user registration for new API provider"/></span></p><p>Then, logout and repeat the process to register a new application developer user too:</p><p><span class="inlinemediaobject"><img src="images/images/example/8.png" alt="Apiman user registration for new app developer"/></span></p><p>Now that the new users are registered we can create the organizations.</p><p>Creating the API Provider Organization</p><p>To create the API provider organization, log back into the API Manager UI as the apiprov user and select “Create a new Organization”:</p><p><span class="inlinemediaobject"><img src="images/images/example/8a.png" alt="Create new organization"/></span></p><p>Select a name and description for the organization, and press “Create Organization”:</p><p><span class="inlinemediaobject"><img src="images/images/example/9.png" alt="Enter new organization details"/></span></p><p>And, here’s our organization:</p><p><span class="inlinemediaobject"><img src="images/images/example/10.png" alt="The new organization"/></span></p><p>Note that in a production environment, users would request membership in an organization. The approval process for accepting new members into an organization would follow the organization’s workflow, but this would be handled outside of the API Manager API. For the purposes of our demonstration, we’ll keep things simple.</p><p>Configuring the API, its Policies, and Plans</p><p>To configure the API, we’ll first create a plan to contain the policies that we want applied by the API Gateway at runtime when requests to the API are made. To create a new plan, select the “Plans” tab. We’ll create a “gold” plan:</p><p><span class="inlinemediaobject"><img src="images/images/example/11.png" alt="Add a new plan"/></span></p><p>Once the plan is created, we will add policies to it:</p><p><span class="inlinemediaobject"><img src="images/images/example/12.png" alt="Add a policy"/></span></p><p>apiman provides several OOTB policies/plans. Since we want to be able to demonstrate a policy being applied, we’ll select a Rate Limiting Policy, and set its limit to a very low level. If our API receives more than 10 requests in a day/month, the policy should block all subsequent requests. So much for a “gold” level of API!</p><p><span class="inlinemediaobject"><img src="images/images/example/13.png" alt="Add and configure rate limiting"/></span></p><p>After we create the policy and add it to the plan, we have to lock the plan:</p><p><span class="inlinemediaobject"><img src="images/images/example/14.png" alt="Lock the plan"/></span></p><p>And, here is the finished, and locked plan:</p><p><span class="inlinemediaobject"><img src="images/images/example/15.png" alt="Plan status is &#34;locked&#34;"/></span></p><p>At this point, additional plans can be defined for the API. We’ll also create a “silver” plan, that will offer a lower level of API (i.e., a request rate limit lower than 10 per day/month) than the gold plan. Since the process to create this silver plan is identical to that of the gold plan, we’ll skip the screenshots.</p><p>Now that the two plans are complete and locked, it’s time to define the API.</p><p><span class="inlinemediaobject"><img src="images/images/example/16.png" alt="APIs tab"/></span></p><p>We’ll give the API an appropriate name, so that providers and consumers alike will be able to run a query in the API Manager to find it.</p><p><span class="inlinemediaobject"><img src="images/images/example/17.png" alt="Add an API"/></span></p><p>After the API is defined, we have to define its implementation. In the context of the API Manager, the API Endpoint is the API’s direct URL. Remember that the API Gateway will act as a proxy for the API, so it must know the API’s actual URL. In the case of our example API, the URL is:  <a class="link" href="http://localhost:8080/apiman-echo" target="">http://localhost:8080/apiman-echo</a></p><p><span class="inlinemediaobject"><img src="images/images/example/18.png" alt="Add implementation information"/></span></p><p>The plans tab shows which plans are available to be applied to the API:</p><p><span class="inlinemediaobject"><img src="images/images/example/19.png" alt="Make API available via available plans"/></span></p><p>Let’s make our API more secure by adding an authentication policy that will require users to login before they can access the API. Select the Policies tab, and then define a simple authentication policy. Remember the user name and password that you define here as we’ll need them later on when send requests to the API.</p><p><span class="inlinemediaobject"><img src="images/images/example/20.png" alt="Add and configure a BASIC auth policy"/></span></p><p>After the authentication policy is added, we can publish the API to the API Gateway:</p><p><span class="inlinemediaobject"><img src="images/images/example/21.png" alt="Added the policy"/></span></p><p>And, here it is, the published API:</p><p><span class="inlinemediaobject"><img src="images/images/example/22.png" alt="Publish the API"/></span></p><p>OK, that finishes the definition of the API provider organization and the publication of the API.</p><p>Next, we’ll switch over to the API consumer side and create the API consumer organization and register an application to connect to the managed API through the proxy of the API Gateway.</p><p>The API Consumer Organization</p><p>We’ll repeat the process that we used to create the application development organization. Log in to the API Manager UI as the “appdev” user and create the organization:</p><p><span class="inlinemediaobject"><img src="images/images/example/23.png" alt="Creating a new organization"/></span></p><p>Unlike the process we used when we created the elements used by the API provider, the first step that we’ll take is to create a new application and then search for the API to be used by the application:</p><p><span class="inlinemediaobject"><img src="images/images/example/24.png" alt="Add a new client app"/></span></p><p><span class="inlinemediaobject"><img src="images/images/example/26.png" alt="Search for APIs to consume"/></span></p><p>Searching for the API is easy, as we were careful to set the API name to something memorable:</p><p><span class="inlinemediaobject"><img src="images/images/example/27.png" alt="Searching for 'echo'"/></span></p><p><span class="inlinemediaobject"><img src="images/images/example/28.png" alt="Found ACME APIs' echo: 'The echo API'"/></span></p><p>Select the API name, and then specify the plan to be used. We’ll splurge and use the gold plan:</p><p><span class="inlinemediaobject"><img src="images/images/example/29.png" alt="Viewing the available contracts"/></span></p><p>Next, select “create contract” for the plan (for this example, we’ll just accept all the defaults):</p><p><span class="inlinemediaobject"><img src="images/images/example/30.png" alt="Creating a new contract"/></span></p><p>The last step is to register the application with the API Gateway so that the gateway can act as a proxy for the API:</p><p><span class="inlinemediaobject"><img src="images/images/example/31.png" alt="API Contracts page on the client app"/></span></p><p><span class="inlinemediaobject"><img src="images/images/example/32.png" alt="Registered the client app"/></span></p><p>Congratulations! All the steps necessary to both provide and consume the configure the API are complete!</p><p>There’s just one more step that we have to take in order for clients to be able access the API through the API Gateway.</p><p>Remember the URL that we used to access the unmanaged API directly? Well, forget it. In order to access the managed API through the API Gateway acting as a proxy for other API we have to obtain the managed API’s URL. In the API Manager UI, header over to the “APIs” tab for the application, select the API and then click select on the “i” character to the right of the API name. This will expose the API Key and the API’s HTTP endpoint in the API Gateway:</p><p><span class="inlinemediaobject"><img src="images/images/example/33.png" alt="APIs tab in client app"/></span></p><p><span class="inlinemediaobject"><img src="images/images/example/34.png" alt="Copy API endpoint info"/></span></p><p>In order to be able access the API through the API Gateway, we have to provide the API Key with each request.  combine the API Key and HTTP endpoint. The API Key can be provided either through an HTTP Header (X-API-Key) or a URL query parameter.</p><p>In our example, the API request looks like this:</p><pre class="screen">https://localhost:8443/apiman-gateway/ACMEAPIs/echo/1.0?apikey=ed4564c1-2715-45f6-881e-ca8bc1168d17</pre><p>Copy the URL into the clipboard.</p><p>Accessing the Managed API Through the apiman API Gateway, Watching the Policies at Runtime</p><p>Thanks for hanging in there! The set up is done. Now, we can fire up the client and watch the policies in action as they are applied at runtime by the API Gateway.</p><p>Open a new browser window or tab, and enter the URL for the managed API.</p><p>What happens first is that the authentication policy is applied and a login dialog is then displayed:</p><p><span class="inlinemediaobject"><img src="images/images/example/35.png" alt="Auth popup prompt"/></span></p><p>Enter the username and password (user1/password) that we defined when we created the authentication policy to access the API. The fact that you are seeing this dialog confirms that you are accessing the managed API and are not accessing the API directly.</p><p>When you send a GET request to the API, you should see a successful response:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JSON">{
 "method" : "GET",
 "resource" : "/apiman-echo",
 "uri" : "/apiman-echo",
 "headers" : {
	"Cookie" : "s_fid=722D028B20E49214-13EAE1456E752098; __utma=111872281.807845787.1452188093.1460777731.1460777731.4; __utmz=111872281.1452188093.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _ga=GA1.1.807845787.1452188093; __qca=P0-404983419-1452188093717; __utmc=111872281",
	"Accept" : "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
	"User-Agent" : "Mozilla/5.0 (X11; Linux x86_64; rv:38.0) Gecko/20100101 Firefox/38.0",
	"Connection" : "keep-alive",
	"X-Identity" : "user1",
	"Host" : "localhost:8080",
	"Accept-Language" : "en-US,en;q=0.5",
	"Accept-Encoding" : "gzip, deflate",
	"DNT" : "1"
 },
 "bodyLength" : null,
 "bodySha1" : null
}</pre><p>So far so good. Now, send 10 more requests and you will see a response that looks like this as the gold plan rate limit is exceeded:</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JSON">{
   "type" : "Other",
   "headers" : {
      "empty" : false,
      "entries" : [
         {
            "X-RateLimit-Remaining" : "-1"
         },
         {
            "X-RateLimit-Reset" : "50904"
         },
         {
            "X-RateLimit-Limit" : "10"
         }
      ]
   },
   "failureCode" : 10005,
   "message" : "Rate limit exceeded.",
   "responseCode" : 429
}</pre><p>And there it is. Your gold plan has been exceeded. Maybe next time you’ll spend a little more and get the platinum plan!  ;-)</p><p>Let’s recap what we just accomplished in this demo:</p><div class="itemizedlist"><ul><li>We installed apiman onto a WildFly server instance.</li><li>We used git to download and maven to build a sample REST client.</li><li>As an API provider, we created an organization, defined policies based on API use limit rates and user authentication, and a plan, and assigned them to an API.</li><li>As an API consumer, we searched for and found that API, and assigned it to an application.</li><li>As a client, we accessed the API and observed how the API Gateway managed the API.</li></ul></div><p>And, if you note, in the process of doing all this, the only code that we had to write or build was for the client. We were able to fully configure the API, policies, plans, and the application in the API Manager UI.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_section_7_apiman_resources"/>Chapter 8. Section 7 - Apiman Resources</h2></div></div></div><div class="itemizedlist"><ul><li>Apiman site - <a class="link" href="http://www.apiman.io/latest/" target="">http://www.apiman.io/latest/</a></li><li>Apiman blog - <a class="link" href="http://www.apiman.io/blog/" target="">http://www.apiman.io/blog/</a></li><li>Apiman downloads - <a class="link" href="http://www.apiman.io/latest/download.html" target="">http://www.apiman.io/latest/download.html</a></li><li>Apiman user guide - <a class="link" href="http://www.apiman.io/latest/user-guide.html" target="">http://www.apiman.io/latest/user-guide.html</a></li><li>Apiman developer guide - <a class="link" href="http://www.apiman.io/latest/developer-guide.html" target="">http://www.apiman.io/latest/developer-guide.html</a></li><li>Apiman videos - <a class="link" href="https://vimeo.com/user34396826" target="">https://vimeo.com/user34396826</a></li><li>Apiman on github - <a class="link" href="https://github.com/apiman" target="">https://github.com/apiman</a></li><li>Apiman on JIRA - <a class="link" href="https://issues.jboss.org/projects/APIMAN" target="">https://issues.jboss.org/projects/APIMAN</a></li><li>Apiman chat on IRC - <a class="link" href="http://www.apiman.io/latest/chat.html" target="">http://www.apiman.io/latest/chat.html</a></li><li>Apiman on Twitter - <a class="link" href="https://twitter.com/apiman_io" target="">https://twitter.com/apiman_io</a></li><li>Apiman mailing list -  <a class="link" href="https://lists.jboss.org/mailman/listinfo/apiman-user" target="">https://lists.jboss.org/mailman/listinfo/apiman-user</a></li><li>Apiman contributors - <a class="link" href="http://www.apiman.io/latest/contributors.html" target="">http://www.apiman.io/latest/contributors.html</a></li></ul></div></div></div></body></html>
