this.workbox=this.workbox||{},this.workbox.strategies=function(e,t,n,s,o,i,a,r){"use strict";try{self["workbox:strategies:5.1.4"]&&_()}catch{}const c={strategyStart:(e,t)=>`Using ${e} to respond to '${i.getFriendlyURL(t.url)}'`,printFinalResponse:e=>{e&&(a.logger.groupCollapsed(`View the final response here.`),a.logger.log(e||"[No response returned]"),a.logger.groupEnd())}};class d{constructor(e={}){this._cacheName=n.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._fetchOptions=e.fetchOptions,this._matchOptions=e.matchOptions}async handle({event:e,request:n}){const i=[];typeof n=="string"&&(n=new Request(n)),t.assert.isInstance(n,Request,{moduleName:"workbox-strategies",className:"CacheFirst",funcName:"makeRequest",paramName:"request"});let o=await s.cacheWrapper.match({cacheName:this._cacheName,request:n,event:e,matchOptions:this._matchOptions,plugins:this._plugins}),l;if(o)i.push(`Found a cached response in the '${this._cacheName}' cache.`);else{i.push(`No response found in the '${this._cacheName}' cache. `+`Will respond with a network request.`);try{o=await this._getFromNetwork(n,e)}catch(e){l=e}o?i.push(`Got response from network.`):i.push(`Unable to get a response from the network.`)}{a.logger.groupCollapsed(c.strategyStart("CacheFirst",n));for(const e of i)a.logger.log(e);c.printFinalResponse(o),a.logger.groupEnd()}if(!o)throw new r.WorkboxError("no-response",{url:n.url,error:l});return o}async _getFromNetwork(e,t){const n=await o.fetchWrapper.fetch({request:e,event:t,fetchOptions:this._fetchOptions,plugins:this._plugins}),r=n.clone(),c=s.cacheWrapper.put({cacheName:this._cacheName,request:e,response:r,event:t,plugins:this._plugins});if(t)try{t.waitUntil(c)}catch{a.logger.warn(`Unable to ensure service worker stays alive when `+`updating cache for '${i.getFriendlyURL(e.url)}'.`)}return n}}class u{constructor(e={}){this._cacheName=n.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._matchOptions=e.matchOptions}async handle({event:e,request:n}){typeof n=="string"&&(n=new Request(n)),t.assert.isInstance(n,Request,{moduleName:"workbox-strategies",className:"CacheOnly",funcName:"makeRequest",paramName:"request"});const o=await s.cacheWrapper.match({cacheName:this._cacheName,request:n,event:e,matchOptions:this._matchOptions,plugins:this._plugins});if(a.logger.groupCollapsed(c.strategyStart("CacheOnly",n)),o?(a.logger.log(`Found a cached response in the '${this._cacheName}'`+` cache.`),c.printFinalResponse(o)):a.logger.log(`No response found in the '${this._cacheName}' cache.`),a.logger.groupEnd(),!o)throw new r.WorkboxError("no-response",{url:n.url});return o}}const l={cacheWillUpdate:async({response:e})=>e.status===200||e.status===0?e:null};class h{constructor(e={}){if(this._cacheName=n.cacheNames.getRuntimeName(e.cacheName),e.plugins){const t=e.plugins.some(e=>!!e.cacheWillUpdate);this._plugins=t?e.plugins:[l,...e.plugins]}else this._plugins=[l];this._networkTimeoutSeconds=e.networkTimeoutSeconds||0,this._networkTimeoutSeconds&&t.assert.isType(this._networkTimeoutSeconds,"number",{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"constructor",paramName:"networkTimeoutSeconds"}),this._fetchOptions=e.fetchOptions,this._matchOptions=e.matchOptions}async handle({event:e,request:n}){const o=[];typeof n=="string"&&(n=new Request(n)),t.assert.isInstance(n,Request,{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"handle",paramName:"makeRequest"});const i=[];let l;if(this._networkTimeoutSeconds){const{id:t,promise:s}=this._getTimeoutPromise({request:n,event:e,logs:o});l=t,i.push(s)}const d=this._getNetworkPromise({timeoutId:l,request:n,event:e,logs:o});i.push(d);let s=await Promise.race(i);s||(s=await d);{a.logger.groupCollapsed(c.strategyStart("NetworkFirst",n));for(const e of o)a.logger.log(e);c.printFinalResponse(s),a.logger.groupEnd()}if(!s)throw new r.WorkboxError("no-response",{url:n.url});return s}_getTimeoutPromise({request:e,logs:t,event:n}){let s;const o=new Promise(o=>{const i=async()=>{t.push(`Timing out the network response at `+`${this._networkTimeoutSeconds} seconds.`),o(await this._respondFromCache({request:e,event:n}))};s=setTimeout(i,this._networkTimeoutSeconds*1e3)});return{promise:o,id:s}}async _getNetworkPromise({timeoutId:e,request:t,logs:n,event:r}){let l,c;try{c=await o.fetchWrapper.fetch({request:t,event:r,fetchOptions:this._fetchOptions,plugins:this._plugins})}catch(e){l=e}if(e&&clearTimeout(e),c?n.push(`Got response from network.`):n.push(`Unable to get a response from the network. Will respond `+`with a cached response.`),l||!c)c=await this._respondFromCache({request:t,event:r}),c?n.push(`Found a cached response in the '${this._cacheName}'`+` cache.`):n.push(`No response found in the '${this._cacheName}' cache.`);else{const e=c.clone(),n=s.cacheWrapper.put({cacheName:this._cacheName,request:t,response:e,event:r,plugins:this._plugins});if(r)try{r.waitUntil(n)}catch{a.logger.warn(`Unable to ensure service worker stays alive when `+`updating cache for '${i.getFriendlyURL(t.url)}'.`)}}return c}_respondFromCache({event:e,request:t}){return s.cacheWrapper.match({cacheName:this._cacheName,request:t,event:e,matchOptions:this._matchOptions,plugins:this._plugins})}}class m{constructor(e={}){this._plugins=e.plugins||[],this._fetchOptions=e.fetchOptions}async handle({event:e,request:n}){typeof n=="string"&&(n=new Request(n)),t.assert.isInstance(n,Request,{moduleName:"workbox-strategies",className:"NetworkOnly",funcName:"handle",paramName:"request"});let i,s;try{s=await o.fetchWrapper.fetch({request:n,event:e,fetchOptions:this._fetchOptions,plugins:this._plugins})}catch(e){i=e}if(a.logger.groupCollapsed(c.strategyStart("NetworkOnly",n)),s?a.logger.log(`Got response from network.`):a.logger.log(`Unable to get a response from the network.`),c.printFinalResponse(s),a.logger.groupEnd(),!s)throw new r.WorkboxError("no-response",{url:n.url,error:i});return s}}class f{constructor(e={}){if(this._cacheName=n.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],e.plugins){const t=e.plugins.some(e=>!!e.cacheWillUpdate);this._plugins=t?e.plugins:[l,...e.plugins]}else this._plugins=[l];this._fetchOptions=e.fetchOptions,this._matchOptions=e.matchOptions}async handle({event:e,request:n}){const l=[];typeof n=="string"&&(n=new Request(n)),t.assert.isInstance(n,Request,{moduleName:"workbox-strategies",className:"StaleWhileRevalidate",funcName:"handle",paramName:"request"});const d=this._getFromNetwork({request:n,event:e});let o=await s.cacheWrapper.match({cacheName:this._cacheName,request:n,event:e,matchOptions:this._matchOptions,plugins:this._plugins}),u;if(o){if(l.push(`Found a cached response in the '${this._cacheName}'`+` cache. Will update with the network response in the background.`),e)try{e.waitUntil(d)}catch{a.logger.warn(`Unable to ensure service worker stays alive when `+`updating cache for '${i.getFriendlyURL(n.url)}'.`)}}else{l.push(`No response found in the '${this._cacheName}' cache. `+`Will wait for the network response.`);try{o=await d}catch(e){u=e}}{a.logger.groupCollapsed(c.strategyStart("StaleWhileRevalidate",n));for(const e of l)a.logger.log(e);c.printFinalResponse(o),a.logger.groupEnd()}if(!o)throw new r.WorkboxError("no-response",{url:n.url,error:u});return o}async _getFromNetwork({request:e,event:t}){const n=await o.fetchWrapper.fetch({request:e,event:t,fetchOptions:this._fetchOptions,plugins:this._plugins}),r=s.cacheWrapper.put({cacheName:this._cacheName,request:e,response:n.clone(),event:t,plugins:this._plugins});if(t)try{t.waitUntil(r)}catch{a.logger.warn(`Unable to ensure service worker stays alive when `+`updating cache for '${i.getFriendlyURL(e.url)}'.`)}return n}}return e.CacheFirst=d,e.CacheOnly=u,e.NetworkFirst=h,e.NetworkOnly=m,e.StaleWhileRevalidate=f,e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private)