this.workbox=this.workbox||{},this.workbox.expiration=function(e,t,n,s,o,i,a,r,c,l){"use strict";try{self["workbox:expiration:5.1.4"]&&_()}catch{}const m="workbox-expiration",d="cache-entries",u=e=>{const t=new URL(e,location.href);return t.hash="",t.href};class f{constructor(e){this._cacheName=e,this._db=new i.DBWrapper(m,1,{onupgradeneeded:e=>this._handleUpgrade(e)})}_handleUpgrade(e){const n=e.target.result,t=n.createObjectStore(d,{keyPath:"id"});t.createIndex("cacheName","cacheName",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1}),a.deleteDatabase(this._cacheName)}async setTimestamp(e,t){e=u(e);const n={url:e,timestamp:t,cacheName:this._cacheName,id:this._getId(e)};await this._db.put(d,n)}async getTimestamp(e){const t=await this._db.get(d,this._getId(e));return t.timestamp}async expireEntries(e,t){const s=await this._db.transaction(d,"readwrite",(n,s)=>{const r=n.objectStore(d),o=r.index("timestamp").openCursor(null,"prev"),i=[];let a=0;o.onsuccess=()=>{const n=o.result;if(n){const s=n.value;s.cacheName===this._cacheName&&(e&&s.timestamp<e||t&&a>=t?i.push(n.value):a++),n.continue()}else s(i)}}),n=[];for(const e of s)await this._db.delete(d,e.id),n.push(e.url);return n}_getId(e){return this._cacheName+"|"+u(e)}}class h{constructor(e,n={}){this._isRunning=!1,this._rerunRequested=!1;{if(t.assert.isType(e,"string",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"cacheName"}),!n.maxEntries&&!n.maxAgeSeconds)throw new o.WorkboxError("max-entries-or-age-required",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor"});n.maxEntries&&t.assert.isType(n.maxEntries,"number",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"config.maxEntries"}),n.maxAgeSeconds&&t.assert.isType(n.maxAgeSeconds,"number",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"config.maxAgeSeconds"})}this._maxEntries=n.maxEntries,this._maxAgeSeconds=n.maxAgeSeconds,this._cacheName=e,this._timestampModel=new f(e)}async expireEntries(){if(this._isRunning){this._rerunRequested=!0;return}this._isRunning=!0;const t=this._maxAgeSeconds?Date.now()-this._maxAgeSeconds*1e3:0,e=await this._timestampModel.expireEntries(t,this._maxEntries),o=await self.caches.open(this._cacheName);for(const t of e)await o.delete(t);e.length>0?(s.logger.groupCollapsed(`Expired ${e.length} `+`${e.length===1?"entry":"entries"} and removed `+`${e.length===1?"it":"them"} from the `+`'${this._cacheName}' cache.`),s.logger.log(`Expired the following ${e.length===1?"URL":"URLs"}:`),e.forEach(e=>s.logger.log(`    ${e}`)),s.logger.groupEnd()):s.logger.debug(`Cache expiration ran and found no entries to remove.`),this._isRunning=!1,this._rerunRequested&&(this._rerunRequested=!1,n.dontWaitFor(this.expireEntries()))}async updateTimestamp(e){t.assert.isType(e,"string",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"updateTimestamp",paramName:"url"}),await this._timestampModel.setTimestamp(e,Date.now())}async isURLExpired(e){if(this._maxAgeSeconds){const t=await this._timestampModel.getTimestamp(e),n=Date.now()-this._maxAgeSeconds*1e3;return t<n}throw new o.WorkboxError(`expired-test-without-max-age`,{methodName:"isURLExpired",paramName:"maxAgeSeconds"})}async delete(){this._rerunRequested=!1,await this._timestampModel.expireEntries(1/0)}}class p{constructor(e={}){this.cachedResponseWillBeUsed=async({event:e,request:t,cacheName:o,cachedResponse:i})=>{if(!i)return null;const r=this._isResponseDateFresh(i),a=this._getCacheExpiration(o);n.dontWaitFor(a.expireEntries());const l=a.updateTimestamp(t.url);if(e)try{e.waitUntil(l)}catch{"request"in e&&s.logger.warn(`Unable to ensure service worker stays alive when `+`updating cache entry for `+`'${c.getFriendlyURL(e.request.url)}'.`)}return r?i:null},this.cacheDidUpdate=async({cacheName:e,request:n})=>{t.assert.isType(e,"string",{moduleName:"workbox-expiration",className:"Plugin",funcName:"cacheDidUpdate",paramName:"cacheName"}),t.assert.isInstance(n,Request,{moduleName:"workbox-expiration",className:"Plugin",funcName:"cacheDidUpdate",paramName:"request"});const s=this._getCacheExpiration(e);await s.updateTimestamp(n.url),await s.expireEntries()};{if(!e.maxEntries&&!e.maxAgeSeconds)throw new o.WorkboxError("max-entries-or-age-required",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor"});e.maxEntries&&t.assert.isType(e.maxEntries,"number",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor",paramName:"config.maxEntries"}),e.maxAgeSeconds&&t.assert.isType(e.maxAgeSeconds,"number",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor",paramName:"config.maxAgeSeconds"})}this._config=e,this._maxAgeSeconds=e.maxAgeSeconds,this._cacheExpirations=new Map,e.purgeOnQuotaError&&l.registerQuotaErrorCallback(()=>this.deleteCacheAndMetadata())}_getCacheExpiration(e){if(e===r.cacheNames.getRuntimeName())throw new o.WorkboxError("expire-custom-caches-only");let t=this._cacheExpirations.get(e);return t||(t=new h(e,this._config),this._cacheExpirations.set(e,t)),t}_isResponseDateFresh(e){if(!this._maxAgeSeconds)return!0;const t=this._getDateHeaderTimestamp(e);if(t===null)return!0;const n=Date.now();return t>=n-this._maxAgeSeconds*1e3}_getDateHeaderTimestamp(e){if(!e.headers.has("date"))return null;const n=e.headers.get("date"),s=new Date(n),t=s.getTime();return isNaN(t)?null:t}async deleteCacheAndMetadata(){for(const[e,t]of this._cacheExpirations)await self.caches.delete(e),await t.delete();this._cacheExpirations=new Map}}return e.CacheExpiration=h,e.ExpirationPlugin=p,e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core)