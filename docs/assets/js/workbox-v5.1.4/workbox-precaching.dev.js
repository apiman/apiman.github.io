this.workbox=this.workbox||{},this.workbox.precaching=function(e,t,n,s,o,i,a,r,c){"use strict";try{self["workbox:precaching:5.1.4"]&&_()}catch{}const g=[],h={get(){return g},add(e){g.push(...e)}};function R(e){h.add(e)}const k="__WB_REVISION__";function E(e){if(!e)throw new r.WorkboxError("add-to-cache-list-unexpected-type",{entry:e});if(typeof e=="string"){const t=new URL(e,location.href);return{cacheKey:t.href,url:t.href}}const{revision:n,url:t}=e;if(!t)throw new r.WorkboxError("add-to-cache-list-unexpected-type",{entry:e});if(!n){const e=new URL(t,location.href);return{cacheKey:e.href,url:e.href}}const s=new URL(t,location.href),o=new URL(t,location.href);return s.searchParams.set(k,n),{cacheKey:s.href,url:o.href}}const x=(e,t)=>{s.logger.groupCollapsed(e);for(const e of t)s.logger.log(e);s.logger.groupEnd()};function y(e){const t=e.length;t>0&&(s.logger.groupCollapsed(`During precaching cleanup, `+`${t} cached `+`request${t===1?" was":"s were"} deleted.`),x("Deleted Cache Requests",e),s.logger.groupEnd())}function v(e,t){if(t.length===0)return;s.logger.groupCollapsed(e);for(const e of t)s.logger.log(e);s.logger.groupEnd()}function A(e,t){const o=e.length,n=t.length;if(o||n){let i=`Precaching ${o} file${o===1?"":"s"}.`;n>0&&(i+=` ${n} `+`file${n===1?" is":"s are"} already cached.`),s.logger.groupCollapsed(i),v(`View newly precached URLs.`,e),v(`View previously precached URLs.`,t),s.logger.groupEnd()}}class u{constructor(e){this._cacheName=t.cacheNames.getPrecacheName(e),this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map}addToCacheList(e){o.assert.isArray(e,{moduleName:"workbox-precaching",className:"PrecacheController",funcName:"addToCacheList",paramName:"entries"});const t=[];for(const n of e){typeof n=="string"?t.push(n):n&&n.revision===0[0]&&t.push(n.url);const{cacheKey:o,url:i}=E(n),a=typeof n!="string"&&n.revision?"reload":"default";if(this._urlsToCacheKeys.has(i)&&this._urlsToCacheKeys.get(i)!==o)throw new r.WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(i),secondEntry:o});if(typeof n!="string"&&n.integrity){if(this._cacheKeysToIntegrities.has(o)&&this._cacheKeysToIntegrities.get(o)!==n.integrity)throw new r.WorkboxError("add-to-cache-list-conflicting-integrities",{url:i});this._cacheKeysToIntegrities.set(o,n.integrity)}if(this._urlsToCacheKeys.set(i,o),this._urlsToCacheModes.set(i,a),t.length>0){const e=`Workbox is precaching URLs without revision `+`info: ${t.join(", ")}
This is generally NOT safe. `+`Learn more at https://bit.ly/wb-precache`;s.logger.warn(e)}}}async install({event:e,plugins:t}={}){t&&o.assert.isArray(t,{moduleName:"workbox-precaching",className:"PrecacheController",funcName:"install",paramName:"plugins"});const n=[],s=[],a=await self.caches.open(this._cacheName),r=await a.keys(),c=new Set(r.map(e=>e.url));for(const[e,t]of this._urlsToCacheKeys)c.has(t)?s.push(e):n.push({cacheKey:t,url:e});const l=n.map(({cacheKey:n,url:s})=>{const o=this._cacheKeysToIntegrities.get(n),i=this._urlsToCacheModes.get(s);return this._addURLToCache({cacheKey:n,cacheMode:i,event:e,integrity:o,plugins:t,url:s})});await Promise.all(l);const i=n.map(e=>e.url);return A(i,s),{updatedURLs:i,notUpdatedURLs:s}}async activate(){const t=await self.caches.open(this._cacheName),n=await t.keys(),s=new Set(this._urlsToCacheKeys.values()),e=[];for(const o of n)s.has(o.url)||(await t.delete(o),e.push(o.url));return y(e),{deletedURLs:e}}async _addURLToCache({cacheKey:e,url:t,cacheMode:n,event:s,plugins:o,integrity:l}){const u=new Request(t,{integrity:l,cache:n,credentials:"same-origin"});let d=await a.fetchWrapper.fetch({event:s,plugins:o,request:u}),h;for(const e of o||[])"cacheWillUpdate"in e&&(h=e);const m=h?await h.cacheWillUpdate({event:s,request:u,response:d}):d.status<400;if(!m)throw new r.WorkboxError("bad-precaching-response",{url:t,status:d.status});d.redirected&&(d=await c.copyResponse(d)),await i.cacheWrapper.put({event:s,plugins:o,response:d,request:e===t?u:new Request(e),cacheName:this._cacheName,matchOptions:{ignoreSearch:!0}})}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(e){const t=new URL(e,location.href);return this._urlsToCacheKeys.get(t.href)}async matchPrecache(e){const n=e instanceof Request?e.url:e,t=this.getCacheKeyForURL(n);if(t){const e=await self.caches.open(this._cacheName);return e.match(t)}}createHandler(e=!0){return async({request:t})=>{try{const e=await this.matchPrecache(t);if(e)return e;throw new r.WorkboxError("missing-precache-entry",{cacheName:this._cacheName,url:t instanceof Request?t.url:t})}catch(n){if(e)return s.logger.debug(`Unable to respond with precached response. `+`Falling back to network.`,n),fetch(t);throw n}}}createHandlerBoundToURL(e,t=!0){const n=this.getCacheKeyForURL(e);if(!n)throw new r.WorkboxError("non-precached-url",{url:e});const s=this.createHandler(t),o=new Request(e);return()=>s({request:o})}}let d;const l=()=>(d||(d=new u),d);function w(e,t=[]){for(const n of[...e.searchParams.keys()])t.some(e=>e.test(n))&&e.searchParams.delete(n);return e}function*O(e,{ignoreURLParametersMatching:t,directoryIndex:n,cleanURLs:s,urlManipulation:o}={}){const i=new URL(e,location.href);i.hash="",yield i.href;const a=w(i,t);if(yield a.href,n&&a.pathname.endsWith("/")){const e=new URL(a.href);e.pathname+=n,yield e.href}if(s){const e=new URL(a.href);e.pathname+=".html",yield e.href}if(o){const e=o({url:i});for(const t of e)yield t.href}}const b=(e,t)=>{const n=l(),s=n.getURLsToCacheKeys();for(const o of O(e,t)){const n=s.get(o);if(n)return n}},C=({ignoreURLParametersMatching:e=[/^utm_/],directoryIndex:o="index.html",cleanURLs:i=!0,urlManipulation:a}={})=>{const r=t.cacheNames.getPrecacheName();self.addEventListener("fetch",t=>{const c=b(t.request.url,{cleanURLs:i,directoryIndex:o,ignoreURLParametersMatching:e,urlManipulation:a});if(!c){s.logger.debug(`Precaching did not find a match for `+n.getFriendlyURL(t.request.url));return}let l=self.caches.open(r).then(e=>e.match(c)).then(e=>e||(s.logger.warn(`The precached response for `+`${n.getFriendlyURL(c)} in ${r} was not found. `+`Falling back to the network instead.`),fetch(c)));l=l.then(e=>(s.logger.groupCollapsed(`Precaching is responding to: `+n.getFriendlyURL(t.request.url)),s.logger.log(`Serving the precached url: ${c}`),s.logger.groupCollapsed(`View request details here.`),s.logger.log(t.request),s.logger.groupEnd(),s.logger.groupCollapsed(`View response details here.`),s.logger.log(e),s.logger.groupEnd(),s.logger.groupEnd(),e)),t.respondWith(l)})};let p=!1;function f(e){p||(C(e),p=!0)}const j="-precache-",S=async(e,t=j)=>{const s=await self.caches.keys(),n=s.filter(n=>n.includes(t)&&n.includes(self.registration.scope)&&n!==e);return await Promise.all(n.map(e=>self.caches.delete(e))),n};function M(){self.addEventListener("activate",e=>{const n=t.cacheNames.getPrecacheName();e.waitUntil(S(n).then(e=>{e.length>0&&s.logger.log(`The following out-of-date precaches were cleaned up `+`automatically:`,e)}))})}function F(e=!0){const t=l();return t.createHandler(e)}function T(e){const t=l();return t.createHandlerBoundToURL(e)}function z(e){const t=l();return t.getCacheKeyForURL(e)}function D(e){const t=l();return t.matchPrecache(e)}const N=e=>{const t=l(),n=h.get();e.waitUntil(t.install({event:e,plugins:n}).catch(e=>{throw s.logger.error(`Service worker installation failed. It will `+`be retried automatically during the next navigation.`),e}))},L=e=>{const t=l();e.waitUntil(t.activate())};function m(e){const t=l();t.addToCacheList(e),e.length>0&&(self.addEventListener("install",N),self.addEventListener("activate",L))}function P(e,t){m(e),f(t)}return e.PrecacheController=u,e.addPlugins=R,e.addRoute=f,e.cleanupOutdatedCaches=M,e.createHandler=F,e.createHandlerBoundToURL=T,e.getCacheKeyForURL=z,e.matchPrecache=D,e.precache=m,e.precacheAndRoute=P,e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core)