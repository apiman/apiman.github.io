this.workbox=this.workbox||{},this.workbox.strategies=function(e,t,n,s,o){"use strict";try{self["workbox:strategies:5.1.4"]&&_()}catch{}const i={cacheWillUpdate:async({response:e})=>200===e.status||0===e.status?e:null};return e.CacheFirst=class{constructor(e={}){this.t=t.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],this.i=e.fetchOptions,this.h=e.matchOptions}async handle({event:e,request:t}){"string"==typeof t&&(t=new Request(t));let i,s=await n.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s});if(!s)try{s=await this.o(t,e)}catch(e){i=e}if(!s)throw new o.WorkboxError("no-response",{url:t.url,error:i});return s}async o(e,t){const o=await s.fetchWrapper.fetch({request:e,event:t,fetchOptions:this.i,plugins:this.s}),i=o.clone(),a=n.cacheWrapper.put({cacheName:this.t,request:e,response:i,event:t,plugins:this.s});if(t)try{t.waitUntil(a)}catch{}return o}},e.CacheOnly=class{constructor(e={}){this.t=t.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],this.h=e.matchOptions}async handle({event:e,request:t}){"string"==typeof t&&(t=new Request(t));const s=await n.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s});if(!s)throw new o.WorkboxError("no-response",{url:t.url});return s}},e.NetworkFirst=class{constructor(e={}){if(this.t=t.cacheNames.getRuntimeName(e.cacheName),e.plugins){const t=e.plugins.some(e=>!!e.cacheWillUpdate);this.s=t?e.plugins:[i,...e.plugins]}else this.s=[i];this.u=e.networkTimeoutSeconds||0,this.i=e.fetchOptions,this.h=e.matchOptions}async handle({event:e,request:t}){const i=[];"string"==typeof t&&(t=new Request(t));const s=[];let a;if(this.u){const{id:n,promise:o}=this.l({request:t,event:e,logs:i});a=n,s.push(o)}const r=this.p({timeoutId:a,request:t,event:e,logs:i});s.push(r);let n=await Promise.race(s);if(n||(n=await r),!n)throw new o.WorkboxError("no-response",{url:t.url});return n}l({request:e,logs:t,event:n}){let s;return{promise:new Promise(t=>{s=setTimeout(async()=>{t(await this.q({request:e,event:n}))},1e3*this.u)}),id:s}}async p({timeoutId:e,request:t,logs:o,event:i}){let r,a;try{a=await s.fetchWrapper.fetch({request:t,event:i,fetchOptions:this.i,plugins:this.s})}catch(e){r=e}if(e&&clearTimeout(e),r||!a)a=await this.q({request:t,event:i});else{const e=a.clone(),s=n.cacheWrapper.put({cacheName:this.t,request:t,response:e,event:i,plugins:this.s});if(i)try{i.waitUntil(s)}catch{}}return a}q({event:e,request:t}){return n.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s})}},e.NetworkOnly=class{constructor(e={}){this.s=e.plugins||[],this.i=e.fetchOptions}async handle({event:e,request:t}){let i,n;"string"==typeof t&&(t=new Request(t));try{n=await s.fetchWrapper.fetch({request:t,event:e,fetchOptions:this.i,plugins:this.s})}catch(e){i=e}if(!n)throw new o.WorkboxError("no-response",{url:t.url,error:i});return n}},e.StaleWhileRevalidate=class{constructor(e={}){if(this.t=t.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],e.plugins){const t=e.plugins.some(e=>!!e.cacheWillUpdate);this.s=t?e.plugins:[i,...e.plugins]}else this.s=[i];this.i=e.fetchOptions,this.h=e.matchOptions}async handle({event:e,request:t}){"string"==typeof t&&(t=new Request(t));const i=this.o({request:t,event:e});let a,s=await n.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s});if(s){if(e)try{e.waitUntil(i)}catch{}}else try{s=await i}catch(e){a=e}if(!s)throw new o.WorkboxError("no-response",{url:t.url,error:a});return s}async o({request:e,event:t}){const o=await s.fetchWrapper.fetch({request:e,event:t,fetchOptions:this.i,plugins:this.s}),i=n.cacheWrapper.put({cacheName:this.t,request:e,response:o.clone(),event:t,plugins:this.s});if(t)try{t.waitUntil(i)}catch{}return o}},e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private)