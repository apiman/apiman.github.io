this.workbox=this.workbox||{},this.workbox.backgroundSync=function(e,t,n,s,o,i){"use strict";try{self["workbox:background-sync:5.1.4"]&&_()}catch{}const d=3,f="workbox-background-sync",a="requests",c="queueName";class p{constructor(e){this._queueName=e,this._db=new i.DBWrapper(f,d,{onupgradeneeded:this._upgradeDb})}async pushEntry(e){s.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"pushEntry",paramName:"entry"}),s.assert.isType(e.requestData,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"pushEntry",paramName:"entry.requestData"}),delete e.id,e.queueName=this._queueName,await this._db.add(a,e)}async unshiftEntry(e){s.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"unshiftEntry",paramName:"entry"}),s.assert.isType(e.requestData,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"unshiftEntry",paramName:"entry.requestData"});const[t]=await this._db.getAllMatching(a,{count:1});t?e.id=t.id-1:delete e.id,e.queueName=this._queueName,await this._db.add(a,e)}async popEntry(){return this._removeEntry({direction:"prev"})}async shiftEntry(){return this._removeEntry({direction:"next"})}async getAll(){return await this._db.getAllMatching(a,{index:c,query:IDBKeyRange.only(this._queueName)})}async deleteEntry(e){await this._db.delete(a,e)}async _removeEntry({direction:e}){const[t]=await this._db.getAllMatching(a,{direction:e,index:c,query:IDBKeyRange.only(this._queueName),count:1});if(t)return await this.deleteEntry(t.id),t}_upgradeDb(e){const t=e.target.result;e.oldVersion>0&&e.oldVersion<d&&t.objectStoreNames.contains(a)&&t.deleteObjectStore(a);const n=t.createObjectStore(a,{autoIncrement:!0,keyPath:"id"});n.createIndex(c,c,{unique:!1})}}const g=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"];class r{constructor(e){s.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"StorableRequest",funcName:"constructor",paramName:"requestData"}),s.assert.isType(e.url,"string",{moduleName:"workbox-background-sync",className:"StorableRequest",funcName:"constructor",paramName:"requestData.url"}),e.mode==="navigate"&&(e.mode="same-origin"),this._requestData=e}static async fromRequest(e){const t={url:e.url,headers:{}};e.method!=="GET"&&(t.body=await e.clone().arrayBuffer());for(const[n,s]of e.headers.entries())t.headers[n]=s;for(const n of g)e[n]!==0[0]&&(t[n]=e[n]);return new r(t)}toObject(){const e=Object.assign({},this._requestData);return e.headers=Object.assign({},this._requestData.headers),e.body&&(e.body=e.body.slice(0)),e}toRequest(){return new Request(this._requestData.url,this._requestData)}clone(){return new r(this.toObject())}}const u="workbox-background-sync",v=60*24*7,l=new Set,h=e=>{const t={request:new r(e.requestData).toRequest(),timestamp:e.timestamp};return e.metadata&&(t.metadata=e.metadata),t};class m{constructor(e,{onSync:n,maxRetentionTime:s}={}){if(this._syncInProgress=!1,this._requestsAddedDuringSync=!1,l.has(e))throw new t.WorkboxError("duplicate-queue-name",{name:e});l.add(e),this._name=e,this._onSync=n||this.replayRequests,this._maxRetentionTime=s||v,this._queueStore=new p(this._name),this._addSyncListener()}get name(){return this._name}async pushRequest(e){s.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"Queue",funcName:"pushRequest",paramName:"entry"}),s.assert.isInstance(e.request,Request,{moduleName:"workbox-background-sync",className:"Queue",funcName:"pushRequest",paramName:"entry.request"}),await this._addRequest(e,"push")}async unshiftRequest(e){s.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"Queue",funcName:"unshiftRequest",paramName:"entry"}),s.assert.isInstance(e.request,Request,{moduleName:"workbox-background-sync",className:"Queue",funcName:"unshiftRequest",paramName:"entry.request"}),await this._addRequest(e,"unshift")}async popRequest(){return this._removeRequest("pop")}async shiftRequest(){return this._removeRequest("shift")}async getAll(){const t=await this._queueStore.getAll(),n=Date.now(),e=[];for(const s of t){const o=this._maxRetentionTime*60*1e3;n-s.timestamp>o?await this._queueStore.deleteEntry(s.id):e.push(h(s))}return e}async _addRequest({request:e,metadata:t,timestamp:s=Date.now()},i){const c=await r.fromRequest(e.clone()),a={requestData:c.toObject(),timestamp:s};t&&(a.metadata=t),await this._queueStore[`${i}Entry`](a),n.logger.log(`Request for '${o.getFriendlyURL(e.url)}' has `+`been added to background sync queue '${this._name}'.`),this._syncInProgress?this._requestsAddedDuringSync=!0:await this.registerSync()}async _removeRequest(e){const n=Date.now(),t=await this._queueStore[`${e}Entry`]();if(t){const s=this._maxRetentionTime*60*1e3;return n-t.timestamp>s?this._removeRequest(e):h(t)}}async replayRequests(){let e;for(;e=await this.shiftRequest();)try{await fetch(e.request.clone()),"dev"!=="production"&&n.logger.log(`Request for '${o.getFriendlyURL(e.request.url)}'`+`has been replayed in queue '${this._name}'`)}catch{throw await this.unshiftRequest(e),n.logger.log(`Request for '${o.getFriendlyURL(e.request.url)}'`+`failed to replay, putting it back in queue '${this._name}'`),new t.WorkboxError("queue-replay-failed",{name:this._name})}n.logger.log(`All requests in queue '${this.name}' have successfully `+`replayed; the queue is now empty!`)}async registerSync(){if("sync"in self.registration)try{await self.registration.sync.register(`${u}:${this._name}`)}catch(e){n.logger.warn(`Unable to register sync event for '${this._name}'.`,e)}}_addSyncListener(){"sync"in self.registration?self.addEventListener("sync",e=>{if(e.tag===`${u}:${this._name}`){n.logger.log(`Background sync for tag '${e.tag}'`+`has been received`);const t=async()=>{this._syncInProgress=!0;let t;try{await this._onSync({queue:this})}catch(e){throw t=e,t}finally{this._requestsAddedDuringSync&&!(t&&!e.lastChance)&&await this.registerSync(),this._syncInProgress=!1,this._requestsAddedDuringSync=!1}};e.waitUntil(t())}}):(n.logger.log(`Background sync replaying without background sync event`),this._onSync({queue:this}))}static get _queueNames(){return l}}class b{constructor(e,t){this.fetchDidFail=async({request:e})=>{await this._queue.pushRequest({request:e})},this._queue=new m(e,t)}}return e.BackgroundSyncPlugin=b,e.Queue=m,e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private)