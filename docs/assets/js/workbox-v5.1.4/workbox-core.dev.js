this.workbox=this.workbox||{},this.workbox.core=function(e){"use strict";try{self["workbox:core:5.1.4"]&&_()}catch{}const t=(()=>{"__WB_DISABLE_DEV_LOGS"in self||(self.__WB_DISABLE_DEV_LOGS=!1);let e=!1;const t={debug:`#7f8c8d`,log:`#2ecc71`,warn:`#f39c12`,error:`#c0392b`,groupCollapsed:`#3498db`,groupEnd:null},s=function(n,s){if(self.__WB_DISABLE_DEV_LOGS)return;if(n==="groupCollapsed"&&/^((?!chrome|android).)*safari/i.test(navigator.userAgent)){console[n](...s);return}const o=[`background: ${t[n]}`,`border-radius: 0.5em`,`color: white`,`font-weight: bold`,`padding: 2px 0.5em`],i=e?[]:["%cworkbox",o.join(";")];console[n](...i,...s),n==="groupCollapsed"&&(e=!0),n==="groupEnd"&&(e=!1)},n={},o=Object.keys(t);for(const t of o){const e=t;n[e]=(...t)=>{s(e,t)}}return n})(),H={"invalid-value":({paramName:e,validValueDescription:t,value:n})=>{if(!e||!t)throw new Error(`Unexpected input to 'invalid-value' error.`);return`The '${e}' parameter was given a value with an `+`unexpected value. ${t} Received a value of `+`${JSON.stringify(n)}.`},"not-an-array":({moduleName:e,className:t,funcName:n,paramName:s})=>{if(!e||!t||!n||!s)throw new Error(`Unexpected input to 'not-an-array' error.`);return`The parameter '${s}' passed into `+`'${e}.${t}.${n}()' must be an array.`},"incorrect-type":({expectedType:e,paramName:t,moduleName:n,className:s,funcName:o})=>{if(!e||!t||!n||!o)throw new Error(`Unexpected input to 'incorrect-type' error.`);return`The parameter '${t}' passed into `+`'${n}.${s?s+".":""}`+`${o}()' must be of type ${e}.`},"incorrect-class":({expectedClass:e,paramName:t,moduleName:n,className:s,funcName:o,isReturnValueProblem:i})=>{if(!e||!n||!o)throw new Error(`Unexpected input to 'incorrect-class' error.`);return i?`The return value from `+`'${n}.${s?s+".":""}${o}()' `+`must be an instance of class ${e.name}.`:`The parameter '${t}' passed into `+`'${n}.${s?s+".":""}${o}()' `+`must be an instance of class ${e.name}.`},"missing-a-method":({expectedMethod:e,paramName:t,moduleName:n,className:s,funcName:o})=>{if(!e||!t||!n||!s||!o)throw new Error(`Unexpected input to 'missing-a-method' error.`);return`${n}.${s}.${o}() expected the `+`'${t}' parameter to expose a '${e}' method.`},"add-to-cache-list-unexpected-type":({entry:e})=>`An unexpected entry was passed to `+`'workbox-precaching.PrecacheController.addToCacheList()' The entry `+`'${JSON.stringify(e)}' isn't supported. You must supply an array of `+`strings with one or more characters, objects with a url property or `+`Request objects.`,"add-to-cache-list-conflicting-entries":({firstEntry:e,secondEntry:t})=>{if(!e||!t)throw new Error(`Unexpected input to `+`'add-to-cache-list-duplicate-entries' error.`);return`Two of the entries passed to `+`'workbox-precaching.PrecacheController.addToCacheList()' had the URL `+`${e._entryId} but different revision details. Workbox is `+`unable to cache and version the asset correctly. Please remove one `+`of the entries.`},"plugin-error-request-will-fetch":({thrownError:e})=>{if(!e)throw new Error(`Unexpected input to `+`'plugin-error-request-will-fetch', error.`);return`An error was thrown by a plugins 'requestWillFetch()' method. `+`The thrown error message was: '${e.message}'.`},"invalid-cache-name":({cacheNameId:e,value:t})=>{if(!e)throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);return`You must provide a name containing at least one character for `+`setCacheDetails({${e}: '...'}). Received a value of `+`'${JSON.stringify(t)}'`},"unregister-route-but-not-found-with-method":({method:e})=>{if(!e)throw new Error(`Unexpected input to `+`'unregister-route-but-not-found-with-method' error.`);return`The route you're trying to unregister was not  previously `+`registered for the method type '${e}'.`},"unregister-route-route-not-registered":()=>`The route you're trying to unregister was not previously `+`registered.`,"queue-replay-failed":({name:e})=>`Replaying the background sync queue '${e}' failed.`,"duplicate-queue-name":({name:e})=>`The Queue name '${e}' is already being used. `+`All instances of backgroundSync.Queue must be given unique names.`,"expired-test-without-max-age":({methodName:e,paramName:t})=>`The '${e}()' method can only be used when the `+`'${t}' is used in the constructor.`,"unsupported-route-type":({moduleName:e,className:t,funcName:n,paramName:s})=>`The supplied '${s}' parameter was an unsupported type. `+`Please check the docs for ${e}.${t}.${n} for `+`valid input types.`,"not-array-of-class":({value:e,expectedClass:t,moduleName:n,className:s,funcName:o,paramName:i})=>`The supplied '${i}' parameter must be an array of `+`'${t}' objects. Received '${JSON.stringify(e)},'. `+`Please check the call to ${n}.${s}.${o}() `+`to fix the issue.`,"max-entries-or-age-required":({moduleName:e,className:t,funcName:n})=>`You must define either config.maxEntries or config.maxAgeSeconds`+`in ${e}.${t}.${n}`,"statuses-or-headers-required":({moduleName:e,className:t,funcName:n})=>`You must define either config.statuses or config.headers`+`in ${e}.${t}.${n}`,"invalid-string":({moduleName:e,funcName:t,paramName:n})=>{if(!n||!e||!t)throw new Error(`Unexpected input to 'invalid-string' error.`);return`When using strings, the '${n}' parameter must start with `+`'http' (for cross-origin matches) or '/' (for same-origin matches). `+`Please see the docs for ${e}.${t}() for `+`more info.`},"channel-name-required":()=>`You must provide a channelName to construct a `+`BroadcastCacheUpdate instance.`,"invalid-responses-are-same-args":()=>`The arguments passed into responsesAreSame() appear to be `+`invalid. Please ensure valid Responses are used.`,"expire-custom-caches-only":()=>`You must provide a 'cacheName' property when using the `+`expiration plugin with a runtime caching strategy.`,"unit-must-be-bytes":({normalizedRangeHeader:e})=>{if(!e)throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);return`The 'unit' portion of the Range header must be set to 'bytes'. `+`The Range header provided was "${e}"`},"single-range-only":({normalizedRangeHeader:e})=>{if(!e)throw new Error(`Unexpected input to 'single-range-only' error.`);return`Multiple ranges are not supported. Please use a  single start `+`value, and optional end value. The Range header provided was `+`"${e}"`},"invalid-range-values":({normalizedRangeHeader:e})=>{if(!e)throw new Error(`Unexpected input to 'invalid-range-values' error.`);return`The Range header is missing both start and end values. At least `+`one of those values is needed. The Range header provided was `+`"${e}"`},"no-range-header":()=>`No Range header was found in the Request provided.`,"range-not-satisfiable":({size:e,start:t,end:n})=>`The start (${t}) and end (${n}) values in the Range are `+`not satisfiable by the cached response, which is ${e} bytes.`,"attempt-to-cache-non-get-request":({url:e,method:t})=>`Unable to cache '${e}' because it is a '${t}' request and `+`only 'GET' requests can be cached.`,"cache-put-with-no-response":({url:e})=>`There was an attempt to cache '${e}' but the response was not `+`defined.`,"no-response":({url:e,error:t})=>{let n=`The strategy could not generate a response for '${e}'.`;return t&&(n+=` The underlying error is ${t}.`),n},"bad-precaching-response":({url:e,status:t})=>`The precaching request for '${e}' failed with an HTTP `+`status of ${t}.`,"non-precached-url":({url:e})=>`createHandlerBoundToURL('${e}') was called, but that URL is `+`not precached. Please pass in a URL that is precached instead.`,"add-to-cache-list-conflicting-integrities":({url:e})=>`Two of the entries passed to `+`'workbox-precaching.PrecacheController.addToCacheList()' had the URL `+`${e} with different integrity values. Please remove one of them.`,"missing-precache-entry":({cacheName:e,url:t})=>`Unable to find a precached response in ${e} for ${t}.`},z=(e,t={})=>{const n=H[e];if(!n)throw new Error(`Unable to find message for code '${e}'.`);return n(t)},F=z;class n extends Error{constructor(e,t){const n=F(e,t);super(n),this.name=e,this.details=t}}const M=(e,t)=>{if(!Array.isArray(e))throw new n("not-an-array",t)},A=(e,t,s)=>{const o=typeof e[t];if(o!=="function")throw s.expectedMethod=t,new n("missing-a-method",s)},C=(e,t,s)=>{if(typeof e!==t)throw s.expectedType=t,new n("incorrect-type",s)},x=(e,t,s)=>{if(!(e instanceof t))throw s.expectedClass=t,new n("incorrect-class",s)},O=(e,t,s)=>{if(!t.includes(e))throw s.validValueDescription=`Valid values are ${JSON.stringify(t)}.`,new n("invalid-value",s)},w=(e,t,s)=>{const o=new n("not-array-of-class",s);if(!Array.isArray(e))throw o;for(const n of e)if(!(n instanceof t))throw o},s={hasMethod:A,isArray:M,isInstance:x,isOneOf:O,isType:C,isArrayOfClass:w},u=new Set;function y(e){s.isType(e,"function",{moduleName:"workbox-core",funcName:"register",paramName:"callback"}),u.add(e),t.log("Registered a callback to respond to quota errors.",e)}const o={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:typeof registration!="undefined"?registration.scope:""},h=e=>[o.prefix,e,o.suffix].filter(e=>e&&e.length>0).join("-"),D=e=>{for(const t of Object.keys(o))e(t)},a={updateDetails:e=>{D(t=>{typeof e[t]=="string"&&(o[t]=e[t])})},getGoogleAnalyticsName:e=>e||h(o.googleAnalytics),getPrecacheName:e=>e||h(o.precache),getPrefix:()=>o.prefix,getRuntimeName:e=>e||h(o.runtime),getSuffix:()=>o.suffix};async function v(){t.log(`About to run ${u.size} `+`callbacks to clean up caches.`);for(const e of u)await e(),t.log(e,"is complete.");t.log("Finished running callbacks.")}const i=e=>{const t=new URL(String(e),location.href);return t.href.replace(new RegExp(`^${location.origin}`),"")},d={filter:(e,t)=>e.filter(e=>t in e)},m=async({request:e,mode:t,plugins:n=[]})=>{const i=d.filter(n,"cacheKeyWillBeUsed");let o=e;for(const e of i)o=await e.cacheKeyWillBeUsed.call(e,{mode:t,request:o}),typeof o=="string"&&(o=new Request(o)),s.isInstance(o,Request,{moduleName:"Plugin",funcName:"cacheKeyWillBeUsed",isReturnValueProblem:!0});return o},b=async({request:e,response:n,event:o,plugins:i=[]})=>{let a=n,r=!1;for(const t of i)if("cacheWillUpdate"in t){r=!0;const n=t.cacheWillUpdate;if(a=await n.call(t,{request:e,response:a,event:o}),a&&s.isInstance(a,Response,{moduleName:"Plugin",funcName:"cacheWillUpdate",isReturnValueProblem:!0}),!a)break}return r||(a&&a.status!==200&&(a.status===0?t.warn(`The response for '${e.url}' is an opaque `+`response. The caching strategy that you're using will not `+`cache opaque responses by default.`):t.debug(`The response for '${e.url}' returned `+`a status code of '${n.status}' and won't be cached as a `+`result.`)),a=a&&a.status===200?a:0[0]),a||null},p=async({cacheName:e,request:n,event:o,matchOptions:i,plugins:a=[]})=>{const l=await self.caches.open(e),c=await m({plugins:a,request:n,mode:"read"});let r=await l.match(c,i);r?t.debug(`Found a cached response in '${e}'.`):t.debug(`No cached response found in '${e}'.`);for(const t of a)if("cachedResponseWillBeUsed"in t){const n=t.cachedResponseWillBeUsed;r=await n.call(t,{cacheName:e,event:o,matchOptions:i,cachedResponse:r,request:c}),r&&s.isInstance(r,Response,{moduleName:"Plugin",funcName:"cachedResponseWillBeUsed",isReturnValueProblem:!0})}return r},E=async({cacheName:e,request:s,response:o,event:a,plugins:r=[],matchOptions:c})=>{if(s.method&&s.method!=="GET")throw new n("attempt-to-cache-non-get-request",{url:i(s.url),method:s.method});const l=await m({plugins:r,request:s,mode:"write"});if(!o)throw t.error(`Cannot cache non-existent response for `+`'${i(l.url)}'.`),new n("cache-put-with-no-response",{url:i(l.url)});const u=await b({event:a,plugins:r,response:o,request:l});if(!u){t.debug(`Response '${i(l.url)}' will `+`not be cached.`,u);return}const f=await self.caches.open(e),h=d.filter(r,"cacheDidUpdate"),g=h.length>0?await p({cacheName:e,matchOptions:c,request:l}):null;t.debug(`Updating the '${e}' cache with a new Response for `+`${i(l.url)}.`);try{await f.put(l,u)}catch(e){throw e.name==="QuotaExceededError"&&await v(),e}for(const t of h)await t.cacheDidUpdate.call(t,{cacheName:e,event:a,oldResponse:g,newResponse:u,request:l})},k={put:E,match:p};let c;function S(){if(c===0[0])try{new ReadableStream({start(){}}),c=!0}catch{c=!1}return c}let r;function g(){if(r===0[0]){const e=new Response("");if("body"in e)try{new Response(e.body),r=!0}catch{r=!1}r=!1}return r}function T(e){e.then(()=>{})}class l{constructor(e,t,{onupgradeneeded:n,onversionchange:s}={}){this._db=null,this._name=e,this._version=t,this._onupgradeneeded=n,this._onversionchange=s||(()=>this.close())}get db(){return this._db}async open(){if(this._db)return;return this._db=await new Promise((e,t)=>{let s=!1;setTimeout(()=>{s=!0,t(new Error("The open request was blocked and timed out"))},this.OPEN_TIMEOUT);const n=indexedDB.open(this._name,this._version);n.onerror=()=>t(n.error),n.onupgradeneeded=e=>{s?(n.transaction.abort(),n.result.close()):typeof this._onupgradeneeded=="function"&&this._onupgradeneeded(e)},n.onsuccess=()=>{const t=n.result;s?t.close():(t.onversionchange=this._onversionchange.bind(this),e(t))}}),this}async getKey(e,t){return(await this.getAllKeys(e,t,1))[0]}async getAll(e,t,n){return await this.getAllMatching(e,{query:t,count:n})}async getAllKeys(e,t,n){const s=await this.getAllMatching(e,{query:t,count:n,includeKeys:!0});return s.map(e=>e.key)}async getAllMatching(e,{index:t,query:n=null,direction:s="next",count:o,includeKeys:i=!1}={}){return await this.transaction([e],"readonly",(a,r)=>{const l=a.objectStore(e),u=t?l.index(t):l,c=[],d=u.openCursor(n,s);d.onsuccess=()=>{const e=d.result;e?(c.push(i?e:e.value),o&&c.length>=o?r(c):e.continue()):r(c)}})}async transaction(e,t,n){return await this.open(),await new Promise((s,o)=>{const i=this._db.transaction(e,t);i.onabort=()=>o(i.error),i.oncomplete=()=>s(),n(i,e=>s(e))})}async _call(t,e,n,...s){const o=(n,o)=>{const i=n.objectStore(e),a=i[t].apply(i,s);a.onsuccess=()=>o(a.result)};return await this.transaction([e],n,o)}close(){this._db&&(this._db.close(),this._db=null)}}l.prototype.OPEN_TIMEOUT=2e3;const j={readonly:["get","count","getKey","getAll","getAllKeys"],readwrite:["add","put","clear","delete"]};for(const[e,t]of Object.entries(j))for(const n of t)n in IDBObjectStore.prototype&&(l.prototype[n]=async function(t,...s){return await this._call(n,t,e,...s)});class N{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}}const L=async e=>{await new Promise((t,n)=>{const s=indexedDB.deleteDatabase(e);s.onerror=()=>{n(s.error)},s.onblocked=()=>{n(new Error("Delete blocked"))},s.onsuccess=()=>{t()}})},R=async({request:e,fetchOptions:o,event:a,plugins:r=[]})=>{if(typeof e=="string"&&(e=new Request(e)),a instanceof FetchEvent&&a.preloadResponse){const n=await a.preloadResponse;if(n)return t.log(`Using a preloaded navigation response for `+`'${i(e.url)}'`),n}s.isInstance(e,Request,{paramName:"request",expectedClass:Request,moduleName:"workbox-core",className:"fetchWrapper",funcName:"wrappedFetch"});const c=d.filter(r,"fetchDidFail"),u=c.length>0?e.clone():null;try{for(const t of r)if("requestWillFetch"in t){const n=t.requestWillFetch,o=e.clone();e=await n.call(t,{request:o,event:a}),"dev"!=="production"&&e&&s.isInstance(e,Request,{moduleName:"Plugin",funcName:"cachedResponseWillBeUsed",isReturnValueProblem:!0})}}catch(e){throw new n("plugin-error-request-will-fetch",{thrownError:e})}const l=e.clone();try{let n;e.mode==="navigate"?n=await fetch(e):n=await fetch(e,o),"dev"!=="production"&&t.debug(`Network request for `+`'${i(e.url)}' returned a response with `+`status '${n.status}'.`);for(const e of r)"fetchDidSucceed"in e&&(n=await e.fetchDidSucceed.call(e,{event:a,request:l,response:n}),"dev"!=="production"&&n&&s.isInstance(n,Response,{moduleName:"Plugin",funcName:"fetchDidSucceed",isReturnValueProblem:!0}));return n}catch(n){t.error(`Network request for `+`'${i(e.url)}' threw an error.`,n);for(const e of c)await e.fetchDidFail.call(e,{error:n,event:a,originalRequest:u.clone(),request:l.clone()});throw n}},P={fetch:R};function f(e){return new Promise(t=>setTimeout(t,e))}const I=2e3;async function B(e){if(!e)return;let t=await self.clients.matchAll({type:"window"});const s=new Set(t.map(e=>e.id));let n;const o=performance.now();for(;performance.now()-o<I;){if(t=await self.clients.matchAll({type:"window"}),n=t.find(t=>e?t.id===e:!s.has(t.id)),n)break;await f(100)}return n}var V=Object.freeze({__proto__:null,assert:s,cacheNames:a,cacheWrapper:k,canConstructReadableStream:S,canConstructResponseFromBodyStream:g,dontWaitFor:T,DBWrapper:l,Deferred:N,deleteDatabase:L,executeQuotaErrorCallbacks:v,fetchWrapper:P,getFriendlyURL:i,logger:t,resultingClientExists:B,timeout:f,WorkboxError:n});const $={get googleAnalytics(){return a.getGoogleAnalyticsName()},get precache(){return a.getPrecacheName()},get prefix(){return a.getPrefix()},get runtime(){return a.getRuntimeName()},get suffix(){return a.getSuffix()}};async function W(e,t){const n=e.clone(),s={headers:new Headers(n.headers),status:n.status,statusText:n.statusText},o=t?t(s):s,i=g()?n.body:await n.blob();return new Response(i,o)}function U(){self.addEventListener("activate",()=>self.clients.claim())}function K(e){{if(Object.keys(e).forEach(t=>{s.isType(e[t],"string",{moduleName:"workbox-core",funcName:"setCacheNameDetails",paramName:`details.${t}`})}),"precache"in e&&e.precache.length===0)throw new n("invalid-cache-name",{cacheNameId:"precache",value:e.precache});if("runtime"in e&&e.runtime.length===0)throw new n("invalid-cache-name",{cacheNameId:"runtime",value:e.runtime});if("googleAnalytics"in e&&e.googleAnalytics.length===0)throw new n("invalid-cache-name",{cacheNameId:"googleAnalytics",value:e.googleAnalytics})}a.updateDetails(e)}function q(){self.addEventListener("install",()=>self.skipWaiting())}return e._private=V,e.cacheNames=$,e.clientsClaim=U,e.copyResponse=W,e.registerQuotaErrorCallback=y,e.setCacheNameDetails=K,e.skipWaiting=q,e}({})