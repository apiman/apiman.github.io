this.workbox=this.workbox||{},this.workbox.routing=function(e,t,n,s,o){"use strict";try{self["workbox:routing:5.1.4"]&&_()}catch{}const u="GET",h=["DELETE","GET","HEAD","PATCH","POST","PUT"],r=e=>e&&typeof e=="object"?(t.assert.hasMethod(e,"handle",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),e):(t.assert.isType(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),{handle:e});class i{constructor(e,n,s=u){t.assert.isType(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"match"}),s&&t.assert.isOneOf(s,h,{paramName:"method"}),this.handler=r(n),this.match=e,this.method=s}}class m extends i{constructor(e,{allowlist:n=[/./],denylist:s=[]}={}){t.assert.isArrayOfClass(n,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.allowlist"}),t.assert.isArrayOfClass(s,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.denylist"}),super(e=>this._match(e),e),this._allowlist=n,this._denylist=s}_match({url:e,request:t}){if(t&&t.mode!=="navigate")return!1;const s=e.pathname+e.search;for(const e of this._denylist)if(e.test(s))return n.logger.log(`The navigation route ${s} is not `+`being used, since the URL matches this denylist pattern: `+`${e}`),!1;return this._allowlist.some(e=>e.test(s))?(n.logger.debug(`The navigation route ${s} `+`is being used.`),!0):(n.logger.log(`The navigation route ${s} is not `+`being used, since the URL being navigated to doesn't `+`match the allowlist.`),!1)}}class l extends i{constructor(e,s,o){t.assert.isInstance(e,RegExp,{moduleName:"workbox-routing",className:"RegExpRoute",funcName:"constructor",paramName:"pattern"});const i=({url:t})=>{const s=e.exec(t.href);if(!s)return;if(t.origin!==location.origin&&s.index!==0){n.logger.debug(`The regular expression '${e}' only partially matched `+`against the cross-origin URL '${t}'. RegExpRoute's will only `+`handle cross-origin requests if they match the entire URL.`);return}return s.slice(1)};super(i,s,o)}}class d{constructor(){this._routes=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{const{request:n}=e,t=this.handleRequest({request:n,event:e});t&&e.respondWith(t)})}addCacheListener(){self.addEventListener("message",e=>{if(e.data&&e.data.type==="CACHE_URLS"){const{payload:t}=e.data;n.logger.debug(`Caching URLs from the window`,t.urlsToCache);const s=Promise.all(t.urlsToCache.map(e=>{typeof e=="string"&&(e=[e]);const t=new Request(...e);return this.handleRequest({request:t})}));e.waitUntil(s),e.ports&&e.ports[0]&&s.then(()=>e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:s}){t.assert.isInstance(e,Request,{moduleName:"workbox-routing",className:"Router",funcName:"handleRequest",paramName:"options.request"});const i=new URL(e.url,location.href);if(!i.protocol.startsWith("http")){n.logger.debug(`Workbox Router only supports URLs that start with 'http'.`);return}const{params:d,route:c}=this.findMatchingRoute({url:i,request:e,event:s});let r=c&&c.handler;const l=[];if(r&&(l.push([`Found a route to handle this request:`,c]),d&&l.push([`Passing the following params to the route's handler:`,d])),!r&&this._defaultHandler&&(l.push(`Failed to find a matching route. Falling `+`back to the default handler.`),r=this._defaultHandler),!r){n.logger.debug(`No route found for: ${o.getFriendlyURL(i)}`);return}n.logger.groupCollapsed(`Router is responding to: ${o.getFriendlyURL(i)}`),l.forEach(e=>{Array.isArray(e)?n.logger.log(...e):n.logger.log(e)}),n.logger.groupEnd();let a;try{a=r.handle({url:i,request:e,event:s,params:d})}catch(e){a=Promise.reject(e)}return a instanceof Promise&&this._catchHandler&&(a=a.catch(t=>(n.logger.groupCollapsed(`Error thrown when responding to: `+` ${o.getFriendlyURL(i)}. Falling back to Catch Handler.`),n.logger.error(`Error thrown by:`,c),n.logger.error(t),n.logger.groupEnd(),this._catchHandler.handle({url:i,request:e,event:s})))),a}findMatchingRoute({url:e,request:n,event:s}){t.assert.isInstance(e,URL,{moduleName:"workbox-routing",className:"Router",funcName:"findMatchingRoute",paramName:"options.url"}),t.assert.isInstance(n,Request,{moduleName:"workbox-routing",className:"Router",funcName:"findMatchingRoute",paramName:"options.request"});const o=this._routes.get(n.method)||[];for(const a of o){let i;const t=a.match({url:e,request:n,event:s});if(t)return i=t,Array.isArray(t)&&t.length===0?i=0[0]:t.constructor===Object&&Object.keys(t).length===0?i=0[0]:typeof t=="boolean"&&(i=0[0]),{route:a,params:i}}return{}}setDefaultHandler(e){this._defaultHandler=r(e)}setCatchHandler(e){this._catchHandler=r(e)}registerRoute(e){t.assert.isType(e,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),t.assert.hasMethod(e,"match",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),t.assert.isType(e.handler,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),t.assert.hasMethod(e.handler,"handle",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.handler"}),t.assert.isType(e.method,"string",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.method"}),this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new s.WorkboxError("unregister-route-but-not-found-with-method",{method:e.method});const t=this._routes.get(e.method).indexOf(e);if(t>-1)this._routes.get(e.method).splice(t,1);else throw new s.WorkboxError("unregister-route-route-not-registered")}}let a;const c=()=>(a||(a=new d,a.addFetchListener(),a.addCacheListener()),a);function f(e,t,o){let a;if(typeof e=="string"){const r=new URL(e,location.href);{if(!e.startsWith("/")&&!e.startsWith("http"))throw new s.WorkboxError("invalid-string",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});const o=e.startsWith("http")?r.pathname:e,t="[*:?+]";new RegExp(`${t}`).exec(o)&&n.logger.debug(`The '$capture' parameter contains an Express-style wildcard `+`character (${t}). Strings are now always interpreted as `+`exact matches; use a RegExp for partial or wildcard matches.`)}const c=({url:t})=>(t.pathname===r.pathname&&t.origin!==r.origin&&n.logger.debug(`${e} only partially matches the cross-origin URL `+`${t}. This route will only handle cross-origin requests `+`if they match the entire URL.`),t.href===r.href);a=new i(c,t,o)}else if(e instanceof RegExp)a=new l(e,t,o);else if(typeof e=="function")a=new i(e,t,o);else if(e instanceof i)a=e;else throw new s.WorkboxError("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});const r=c();return r.registerRoute(a),a}function p(e){const t=c();t.setCatchHandler(e)}function g(e){const t=c();t.setDefaultHandler(e)}return e.NavigationRoute=m,e.RegExpRoute=l,e.Route=i,e.Router=d,e.registerRoute=f,e.setCatchHandler=p,e.setDefaultHandler=g,e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private)